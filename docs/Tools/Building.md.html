<style class="fallback">@media screen{body{background:#0F0F0F;color:#ccc}}</style>
<link rel="stylesheet" href="../libs/markdeep_slate.css">
<script src="https://kit.fontawesome.com/ed883494f6.js" crossorigin="anonymous"></script>

(#) [Back to INDEX]("../doc_index.md.html"))

# Building with SqueLib

# Build Scripts

The build scripts will be explained first on Linux as I believe the syntax provided makes the most sense and provides a better introduction to command line basics and then the changes in Windows.

If syntax between platforms does not differ, it will not be repeated below.

## From Linux
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash linenumbers
   mkdir cmake_files_platformY
   cd cmake_files_platformY
   open_console --no_close -execute cmake "dir" -DToPlatformY=1 -DCMAKE_BUILD_TYPE=Debug
   open_console --no_close -execute> cmake --build .
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The most basic build script will consist in some form of this pseudocode:

**Lines 1-2:** Create a folder and navigate there in order to contain the CMake generated files and not pollute the repository:

 * `mkdir "relative_path/foldername`: create directory at relative path to execution directory and specified final name. There are a lot of options, look it up on google.
 * `cd`: Navigate to specified directory, can be full or relative path.

**Line 3:** Generate the build files for compilation
 
 * `open_console`: call to your preferred konsole instance to open and later execute a command
 * `--no_close`: console option to avoid closing and be able to read output
 * `-execute`: call function to execute a command. -e on Konsole and 
 * `cmake "dir"`: call cmake under a specified directory (CMAKE_SOURCE_DIR variable). I personally store scripts in the same folder as CMakeList.txt, because we navigated one folder up, i leave it as "**../**".
 * `-DToPlatform=1`: SqueLib option for platform, i use defines for this, currently supporting ToWindows/ToLinux/ToAndroid.
 * `-DCMAKE_BUILD_TYPE=[Debug / Release]`: Select type of build. On MSVS it does not matter much.

 **Line 4:** Build the project executable and binaries:

  * `--build`: cmake option to build the project
  * `"dir"`: directory used for wirting binary files (CMAKE_BINARY_DIR variable).

## From Windows

On windows it is similar but you don't have to specifically call to a console, just us a .bat extension and you're good to go.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash linenumbers
    mkdir cmake_files_platformY 
    cd cmake_files_platformY
    cmake ../ -UToAndroid -UToLinux -DToWindows=1 -DCMAKE_BUILD_TYPE=Release
    cmake --build . 
    cmd /k
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  * `cmd/k`: as we are not explecitly opening a CLI for each call, to keep them open you call cmd to open the execution in command prompt with option `/keep` to make it not close automatically.

# Command Line Basics

Throughout the use of CMake, you will encounter multiplatform pitfalls in which the fastest way will be to create some platform/CLI specific command calls. Below I will point out some specifics that will help in the basic things I used in this project:

 * `@echo "Message"`: Write log to console 
 * `mkdir -p`: option to create parent directories if the specified are not found, thus creating a folder structure.
 * `cp -options "source" "destination"`: copy files/directories in Linux, [fast documentation](https://www.rapidtables.com/code/linux/cp.html).
 * `robocopy "source" "destination" /Options`: copy files/directories in Windows, [fast documentation](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/robocopy).
 * `rm -options "path"`: remove files/directories.
 * `VARIABLE="Value"`: Declare a local variable for using in following calls
 * `envsubst '$$Local_Variables' < path_to/text_file_with_Variables.extension > path_to/final_file_with_name.extension`: Great funcion to define a template file and then substitute with defined variables preceded by 2 dollar signs. Examples are **Android.xml.template** and **squelib_add_targets** macro in **AndroidInstallTargets.cmake**.
 * `ls -options "directory/file"`: list the contents in a directory or file.

Command Line Interfaces are one hell of a powerful tool anyone into programming has to master. I don't think I even get to beginner, I just use these usual commands and go by looking up what I am told to do to understand it, more commands will be introduced explaining the CMake Android Modules as there are specific commands required for the build.

# CMake in SqueLib

First of all, if you want a truly great introduction, go to Jeff Preshing's [Learn CMake's scripting language in 15 miunutes](https://preshing.com/20170522/learn-cmakes-scripting-language-in-15-minutes/) and [How to build CMake Projects](https://preshing.com/20170511/how-to-build-a-cmake-based-project/). I started off of these two and I am glad I found them.

SqueLib is not a heavy CMake project as some experienced users might easily discern, there are a couple not recommended to say the least uses and ugly things, but they work just as intended.

CMake's documentation is extensive but straight to the point with examples of usage in complicated function calls. To make it easier to read, here are a small list of general rules:

 * `set(VARIABLE_NAME VALUE)`: Declare/Define a Variable
 * `${VARIABLE_NAME}`: Access the value of a variable
 * `function(VARIABLE value_input ...)`: Most functions have a string that declare which variable they target as function might have a plethora of unordered variable to set. As an example: `project(SqueLib VERSION 2021.1)`, the project function has a lot of variables or options to set, we are specifying that VERSION is set to 2021.1, these variable setting can be concatenated with more like `... DESCRIPTION "Something" LANGUAGES C ...)`.
 * `macros` substitute the call with the code itself, thus making all variables accessible to the local space.
 * `functions` don't make the variables declared inside available unless specified

 With these simple directives set, let's get through the following example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cmake linenumbers
    cmake_minimum_required(VERSION 3.1)
    # Project Settings
    project(SquePong VERSION 2021.1 LANGUAGES C CXX)
    set(CMAKE_CXX_STANDARD 17)
    set(CMAKE_CXX_STANDARD_REQUIRED ON)
    set(CMAKE_CXX_EXTENSIONS ON)
    
    # Add source directory where SqueLib's CMakeList.txt is, and where to write files
    add_subdirectory("${CMAKE_CURRENT_SOURCE_DIR}/SqueLib ${CMAKE_CURRENT_BINARY_DIR}/SqueLib)

    # Setup the Build paths
    execute_process(COMMAND mkdir -p ${CMAKE_CURRENT_SOURCE_DIR}/builds)
    set(CMAKE_BINARY_DIR ${CMAKE_CURRENT_SOURCE_DIR}/builds)

    # SqueLib Required Functions
    SqueLib_PrepareBuild(SquePong MarcTorresJimenez "${CMAKE_CURRENT_SOURCE_DIR}/main.cpp")
    SqueLib_Package("" "")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First of all you setup the minimum version of CMake to use, you don't want to use functions that a user might not support, rather throw an error.

Then you setup your basic project settings, I recommend taking a look at documentation on which language and project options are. For this we are making sure that the build can compile C and C++ code, making sure to compile with C++17 standard.

To add a subproject, it is usual to add the subdirectory where the CMakeList.txt is, then specifying where CMake should write the generated files.

I personally setup the build paths under a build folder and then point the CMAKE_BINARY_DIR to write files at that directory.

Finally, we call the preparation calls for SqueLib:
 * `SqueLib_PrepareBuild(target OrganizationName "${List_of_files_to_build_with}")`:
 * `SqueLib_Package("Path_To_App_Assets" "Path_to_Base_Resources")`:

# CMake Modules

<!-- -------------------------------------------------------------------------------------------- -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script>markdeepOptions={tocStyle:'long'};</script>
<script src="../libs/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
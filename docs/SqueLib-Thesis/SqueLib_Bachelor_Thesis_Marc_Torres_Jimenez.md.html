<meta charset="utf-8" lang="en">

<script>
var titlePage = {
      institution: "Universitat Politécnica de Catalunya"
    , institutionExtra: `Centre de la Imatge i Tecnologia Multimèdia`
    , thesisKind: "Bachelor's Thesis in Game Development"
    , thesisTitle: "C++ for multiplatform development"
    , thesisSubtitle: "SqueLib and SqueMaker, introduction to cross-platform C++"
    , thesisAuthor: "Marc Torres Jimenez"
    , thesisDate: "March 2021"
    , reviewers: [
          `Jesús Díaz García
           Senior Graphics Programmer
           Universitat Politècnica de Catalunya
          `
      ]
  }
</script>

<!-- RUBRICA 1 -->

(##) Abstract

Videogame development takes place not only on leading performance platforms, but primarily on emerging technologies and mobile platforms, relegating the priority on these classically more mature platforms to experimentnig on limits of current hardware and focusing on more lucrative endeavours on other platforms.

As C++ has been traditionally taught and learned for providing mainly desktop computer experiences, a push for providing standardized environments for developing videogames and other kinds of applications have moved developers away from C++ and brought them to specialized software or other languages.

With the growth of specialized alternatives for mobile platforms and the appearance of more memory safe languages, the approach to develop multiplatform C++ native applications fades out.

SqueLib<sub>[#W1]</sub> is a C++ library and framework for developing multiplatform C++ based applications that focuses on providing an quick introduction to multiplatform development to C++ developers who have traditionally focused on desktop platforms.

A second focus on SqueLib is its ease of expansion and integration with other libraries, allowing users to integrate into their project as a wrapper or as a founding stones of their project.

The result of the project provides SqueLib, examples on using SqueLib and SqueMaker<sub>[#W2]</sub>, a simple game engine which makes full use of the library. The process of implementation is also explained in this document. 

The SqueMaker game engine will be provided both as a source code package and an executable that can be executed in any Windows machine and Ubuntu based Linux distributions (tested under KDE<sub>[#W3]</sub>), with capabilities of building for said platforms as well as Android.

The source code for the resulting projects will be open sourced under the BSD-3-Clause<sub>[#W4]</sub>, permitting redistribution of the source code providing the copyright notice, redistribution of the binary that reproduces the copyright notice for the project, without using such notice as an endorsement for the derived products.

<span class="pagebreak"></span>

(##) Keywords

C++, CMake, OpenGL, GLFW, EGL, Android, NDK, Windows, Linux, Multiplatform, Engine

(##) Project Links

**W1 -** SqueLib Github Repository<sub>[#W1]</sub>

**W2 -** SqueMaker Github Repository<sub>[#W2]</sub>

<!-- add links to resulting apps, games,... -->
<span class="pagebreak"></span>

(##) Glossary

| Term | Description |
|---|---|
| GPU | Graphics Processing Unit |
| API | Application Programming Interface |
| Full Stack | Pertaining to all areas of specific software development |
| KDE | K Desktop Environment, Linux desktop environment |
| CMake | Open-source cross-platform tols for building, testing and packaging software |
| OpenGL | Open Graphics Library, cross-language and cross-platform graphics programming interface |
| GLFW | Open-source API used in this project for creating windows and main contexts for OpenGL, with capabilities for context for OpenGL ES and Vulkan; as well as receiving inputs and events. Usable on main desktop platforms such as Linux and Windows, as well as MacOS which is not targeted in this thesis. Android specifically requires EGL to interface with OpenGLES. |
| EGL | Native window management API for interfacing with OpenGL, OpenGLES and Vulkan |
| Android NDK | Toolset for implementing native Android apps in pure C/C++, also allowing for calls to Java Native code. Previous to it is was strictly necessary to explicitly create a Java based application and load C/C++ code from it, as well as interact with a Java Native Interface, which is still required for some functionality |
| Web Stack | Commonly referred to a package for tacking care of a website which require a base Operative Syste, a Web Serve, a database manager and the programming languages for interfacing with them |
| (Programming) library | Set of portable code that focuses in tackling a set of issues. **Examples: GLM**: a library for performing geometric mathematical operations with the same syntax as OpenGL. **/ Parson**: a C++ library that facilitate the parsing of JSON files |
| Game Engine | Software Tool that streamlines the process of making a game by including most technology required for a game developer to focus on designing and developing a game |
| Software Framework | Set of solutions for dealing with a software need, which may include a programming library. **Examples: Plywood problem |

| Term | Description |
| --- | --- |
| Direct3D | Graphics API for interfacing on Microsoft Platforms such as Windows desktop PCs and XBox consoles, tagetting realtime 3D graphics. There are multiple versions, with the latest, DirectX12, focusing on a lower level approach to interfacing with hardware |
| Vulkan | Low level graphics and computing API, oriented at high performance with 3D graphics applications, across multiple platforms |
| Metal | Apple's low level graphics API for usage in iOS, iPadOS, macOS and tvOS (Apple's proprietaty Operative Systems) |
| SDK | Software Development Kit, suite of tools for developing project under a certain specification (Example: Android SDK, for building Android Projects) |
| Toolchain | Specific set of tools used for building a projects |
| APK | Android Package Kit, uncrompressed packet type used for denominating Android application |
| ADB<sub>[#W46]</sub> | Android Debug Bridge, tool for interfacing with Android physical devices |


<span class="pagebreak"></span>

# Introduction

Every creator wants to create, be it products, tools, works of art or the specifically desired object of creation. In the software development industry the tradition has shifted from producing from scratch to producing for the creators and these creators to make use of the available tools and products to make their creations.

The contemporary landscape of videogame development focuses on the usage and mastery of game engines in order to produce works of art, which make full use of the available technology under an abstraction layer that obfuscates the inner workings from the developer. This abstraction, which is present in some way or another on any software development process, separates the creative potential form the creators from the lower level technical requirements.

This breakthrough in creative control comes at a cost of a long term drought on technologic savviness and locking these creatives into their chosen environments, a problem that is clearly found in modern day software which tends to deferr performance to last place. When facing different challenges different tools must be used or even made up to tackle them, which is initially limited or locked for the users entering these environments.

Resulting from this thesis is an introduction to taking control on the process of development before being locked on the creative process, providing a knowhow into the continuous development of projects outside the final product.

## Motivations

During the coursing of the Bachelor's Degree in Videogame Design and Development, the introduction to other platforms came at the cost of being locked in specific environments. This experience mirrors closely what can be found easily as better practices,which create a higher entry cost to newer platforms, when working with C++.

If you want to work in Android you will be introduced to languages and tools such as Java/Kotlin and Android Studio, Flutter or React Native. If you want to work in Web Development you will be mostly forced into one of the infinite variants of the Web Stack and generating infinite dependecies.

As an opportunity to grow as a C++ programmer and provide a learning experience for others to come, the creation of a library that allows a faster introduction to other platforms without the buffer time of learning a completely new environment and language, seem to fit me the most.

## Problem Statement

When developing a videogame, platforms other than initial targets demand a massive scope extension for the development. Markets are not to be ignored in some projects but the cost of increasing the scope are very limiting to smaller productions. With proper initial planning existing solutions can be applied easily, but are less flexible than being capable of driving a project towards a multiplatform environment mid-development.

SqueLib<sub>[#W1]</sub> aims to provide a base from which a smaller C++ based production can rely on to take care of the core subsystems that allow the project to execute on Android, Linux and Windows. As well as providing a learning experience in what hides under the process of having a C++ application run on multiple platforms without apparent specific code on the developers' part.

The resulting project can be easily modified and integrated according to the developer's interests, a base solution that requires usage of SqueLib's systems without code rewriting for any platform and subsystems provided. 

On the other hand SqueMaker<sub>[#W2]</sub> primary mission is to provide a simple game engine that can be toyed with, for understanding how the modules work and to allow the implementation of them in different ways.

To summarize, SqueLib and SqueMaker are projects to introduce C++ desktop developers to multiplatform development. Alongside the results, documention and tools for testing the progression from building to getting an application running will be provided, focusing on game development.

<span class="pagebreak"></span>

## General Objectives

### SqueLib General Objectives

The process of developing or increasing development scope to target multiple platforms is a tremendous headache when developing C++ based games, even when most widely available and used libraries are multiplatform capable by nature and most platform provide the mainly required components for running C++ compiled applications.

Non-desktop environments mostly lock their development libraries and APIs under licensing and development agreements, which makes the jump from an open environment to more obfuscated platforms hard.

Given these issues, the jump mostly goes from desktop development to product development in game engines and specific software. This project tries to provide an introduction to this development as well as creating a library that makes it easier to enter while keeping full control on technology and creativity.

Main objectives for this thesis include:
1. Design and Develop a multiplatform application building library for C++
2. Open-source the resulting project under BSD-3-Clause License<sub>[#W4]</sub>
3. A learning experience into multiplatform Development
4. Provide examples and demonstration for the subsystems of the library

### SqueMaker General Objectives

Developing games is hard, there are lots of areas of knowledge required to accomplish the creation of a videogame. Deepening the knowledge in the provided subsystems and having a playground to comfortably learn new about new areas, is essential to developing focused paths of success.

As a personal interest in learning more about each new topic of interest, it coincides with having an accessible engine which can be easily modified to learn about both older and emerging technologies.

Main objectives for the engine are:
1. Develop a toy engine to play with the provided subsystems and make simple games
2. Make a flexible engine that can accomodate new features and technologies
3. Be able to quickly iterate over the implemented technologies 

<span class="pagebreak"></span>

## Specific Objectives

### SqueLib Specific Objectives

In order to provide this multiplatform entry without veering off C++, the library must not only provide the source C++ code but the wrapping elements that are necessary for working seamlessly on multiple environments, while not losing control over them.

#### Display Management

**Window Creation:** Multi-window support with flexible options for the rendering backend.

**Customizable windows:** Application names, size, refresh,... provide main expected options for the user.

#### Rendering System

**Pipeline:** Create a simple but flexible pipeline that does not deviate too much from chosen backend.

**Shaders:** Facilitate usage of shaders and tools around them without limiting flexibility.

**Data:** Create classes and functions that have a description on creation for a pragmatic approach to rendering, but still allowing flexibility.

#### Input System

**Desktop Input:** Support for traditional Mouse and Keyboard input with reprogrammable actions.

**Touch Input:** Support for multi-touch input necessary for mobile devices, that translate well to desktop environment to facilitate implementation.

**Simple Gestures:** Example on how gestures are created and managed.

#### File Access

**File Load/Write:** Filetype agnostic easy disk load/write binary files, prefer binary loading and writing data to memory first then act on disk on the full parsed file/constructed data.

**Directory Operations:** Creation, destruction and copy of directories, as well as flexible and threadable check operations for held data in directories.

<!--**Sound System**--> 

### SqueMaker Specific Objectives

As mentioned, the creation of a game requires knowledge in lots of areas. The creation of a tool that can make games requires the implementation of that knowledge and have it accessible to the end user.

**Rendering Pipeline** using the core provided by the library but remains flexible for developers, separated from the core of executing the application.

**Asset Management** robust enough to support constant iteration and secure to lessen the requirements of data management from the user.

**Entity Component System** that implements a somewhat flexible approach to managing neutral objects but specifically in a data oriented way, providing a strong base for performant systems. 

**Fast Logic implementation and iteration**, summarized in a non-locking environment for testing the logic code. Encourage the use of external tools but still maintain a strong link with the engine in order to debug and improve on the code.

## Project Scope

Both the creation of a stable library and making a game engine are not quick and easy jobs. Both require a considerable amount of time to polish and have at state of the art, because of the wide area of knowledge required to make the feature complete.

Most custom engine target specific platforms with a specific set of tools and libraries which are provided. Making use of such tools and libraries are key to making the library fast to reach usable states and more stable releases, while the engine relies more heavily on the constant implementation of usability features.

As the basis for this project thesis and the actual time available is limited and a single person will be working on it, instead of hundreds of talented individuals, clear cuts have to be made to have them on time.

The amount of features will be closely examined and mostly non-expanded or even cut over time. Making a playground includes room for creativity and innovation alongside the project instead of within the project. Visual polish and accessibility might be cut down too, although it is an area of interest for making it more available as a learning environment.

All in all, this project is aimed at providing C++ developers with an introduction and a multiplatform library for game development in C++, without distinction between professionals or students, individuals or companies.

Under the State of the Art section, how this problem has been tackled by contemporary solutions will be explained.

# State of the Art

Until the smartphone revolution consolidated itself with the iOS and Android operative systems, cross-platform specific tools were close to non-existent. Videogames were developed for target platforms and later ported to other ones if it were expected to be a successful endeavour. 

Around that time multiplatform development were taken by dedicated porting studios for specific platforms, who continue to be relevant nowadays as both console systems and mobile platforms maintain somewhat of a barrier of entry.

At the same time, previous endeavours to make libraries or frameworks for specific subsystems have gained a ton of traction among the indie community as the porting services are not as attainable for them. Open access and resources available through OSS<sub>[#W5]</sub> are the driving forces behind most academic and institutions development efforts, as well as a strong pillar of lots of products developed.

The last approach to gain the most traction are the generic game engines, meaning that the technologies provided are meant to be game genre agnostic and provide a base package from which any game can be created.

For project availability and focus of the thesis, open-source and free widely available game engines will be taken into account, both of which must have multiplatform capabilites for specific subsystems of the whole development of a game.

## C/C++ Multiplatform Open Source Software

As a C++ developer, there is a plethora of available open-source libraries and frameworks for every subsystem and for full stack development. Most well known projects are great entry points for game development, as they provide great documentation and over the years a lot of community supported content for both experienced and new users.

Because of the extension of the open-source software landscape, the reviewed projects will fall under the most basic subsystems to get an application running and which I have previous knowledge of or experience with. For an explicitly extensive list of great open-source projects in C++ refer to Awesome-Cpp<sub>[#W14]</sub>.

### SDL

The Simple DirectMedia Layer<sub>[#W19]</sub> is a library made to ease the process of developing multiplatform games while still having access to native performance on the provided subsystems. It's written in C and is C++ capable as well as having bindings to C# and Python, among others. It is licensed under ZLIB license so it can be used for closed-source projects by static linkage.

SDL provides a wrapping framework from operating-system-specific functions for a game to run and the following subsystems: sound, 2D pixel operations, file access, event handling, timing, multithreading, input and setting up of graphics backend, mainly OpenGL, Direct3D, Vulkan and Metal (although there are more unofficially supported).

The project is very mature, with a major version change in 2013 to SDL 2.0 which distanced itself from the previous versions, and continues to be updated to this day. A great testament of this is its use in both professional and educational environments for making games, with an extensive list of games, engines, emulators and various applications using it.

### RayLib

RayLib<sub>[#W20]</sub> is self-described as a simple and easy-to-use library to enjoy programming videogames. Ramon Santamaria open sourced the project in 2013 and had a recent major update in RayLib 3.5 in December 2020. 

The project is not just a library but a whole development suite for making games and applications in C/C++, including tools and all subsystems necessary for making a game, as well as a math module for the main operations and structures used in games (**Figure 1**).

![Figure [figures]: Raylib 3.5 Architecture, submodules and supported platforms.](images/Raylib_Modules.png)

### Rawdraw

Rawdraw<sub>[#W26]</sub> is mostly a drawing system for OpenGL, with an agnostic approach to the functions required to interact with operative systems, but also supporting software rasterization when graphics acceleration is not available. It's written in C and can be either fully compiled as a submodule or as a header in your project.

Its main appeal is that is extremely lean and very quick to prototype with, it is supported in mostly any device available out there that supports C compiled programs, and provides the essential to generate what it offers: a simple OpenGL/Rasterization drawing interface.

![Figure [figures]: Rawdraw Test](images/RawDraw.jpg) 

Instead of a full documentation and tutorials, there is a single test app that it is compiled from base with Rawdraw(**Figure 2**) and then ColorChord<sub>[#W27]</sub>, a program to interact with colors from sound. 

## Game Engines

From a user standpoint, public game engines are the most comfortable environments for making games. Development time is cut down drastically with available technologies and accessible, they enhance the creative experience while obfuscating part of the technologic requirements for an easier entry.

There are also proprietary engines, which are used and own by specific studios, which benefit from more direct technologic development but they will not be covered here.

Besides the following engines, there are more engines which have different features to offer for better or for worse. In this recollection, a brief introduction and basic strengths and weaknesses pertaining to initial development will be taken into account, as well as some developed games.

### Unity

Unity<sub>[#W6]</sub> is a cross-platform game engine, unveiled at the Wordwide Developers Conference 2005, built as an OS-X exclusive game engine. Over time, it has extended support to other desktop platform and emerging platforms. Nowadays supports most widely available platforms, be it console, mobile, desktop and IOT devices.

| STRENGTHS | WEAKNESSES |
|-------|---------|
| 3D and 2D Game Support | Comparably low performance (including DOTS) |
| Mostly unparalleled platform support | Unsteady direction of development |
| Accessible Interface | Messy Rendering Pipeline support (HDRP, URP, SRP) |
| Open Marketplace for developers of Assets and Tools | Outdated Network System |
| Robust Subsystems for physics, logic and asset management | Slow Build process on mobile platforms |
| Continuous development and improvement of tools and technology| Closed source code |
| Tier based licensing with royalties | |
| Vast knowledge base in tutorials, examples and documentation| |

<span class="pagebreak"></span>

!!! Tip: Game Examples
    Used in multiple indie games and solo production as well as big studios: Hearthstone (Blizzard-Activision, 2014), Fall Guys (Mediatonic, 2020), Ori and the Will of the Wisps (Moon Studios, 2020), Cuphead(Studio MDHR, 2017), Flappy Bird(Don Nguyen, 2013),...

### Unreal Engine 4

The fourth version coming from the Unreal Engine<sub>[W.7]</sub> series is a great high value production tool for smaller teams and some supported individuals. It started in 1998 as the engine for the first-person shooter game series Unreal Tournament, by Epic Games. The engine has slowly moved into film and TV productions and has been providing support for smaller creators all around.

| STRENGTHS | WEAKNESSES |
|-------|---------|
| Focus on high quality 3D graphics | Lacking support for 2D games |
| Robust an daccessible visual tools for programming and visual effects | Suited for bigger productions |
| Great tools for massive scale projects | Although better than past, not suitable for low-end device products|
| High performance oriented technology | Outdated UI although improving at a fast pace |
| Open sourced code | |
| Royalty based licensing starting at one million $ | |
| Open Marketplace for developers of Assets and Tools| |

!!! Tip: Game Examples
    Guilty Gears Strive (Arch Systems, 2021), Fortnite (Epic Games, 2017), A Way Out (Retro Yeti Games, 2018), Ark Survival Evolved (Studio Wildcard, 2017), Batman: Arkham Asylum (Rocksteady Studios, 2016),...

### Godot

The Godot<sub>[#W8]</sub> engine is an open-source cross-platform engine, released by Juan Linietsky and Ariel Manzur in 2014, with the latest release being on September 2020. It aims to be as accessible while maintaining the capabilities of a fully fledged commercial engine.

| STRENGTHS | WEAKNESSES |
|---|---|
| Very accessible visual tools for everything it brings | Slower 3D performance for bigger projects |
| High level of customization and expansion | Smaller ecosystem |
| Fully open-source and free | Smaller industry impact |
| Essential support of major platforms | Slower adoption of newer technologies |
| Flexible language support | Some platforms are only supported through dedicated porting studios |
| Very Strong 2D tool supports | |

!!! Tip: Game Examples
    Human Diaspora (Leocesar3D, 2020), Kingdoms of the Dump (Roach Games, Kickstarter 2019), Ex Zodiac (Ben Hickling, 2021), Resolutiion (Monolith of Minds, 2020),...

### Game Maker Studio 2

Created by Mark Overmars originally in 1999, later acquired by YoYo Games in 2007, the Game Maker<sub>[#W23]</sub> series of engines are cross-platform engines geared to introduce novice programmers to game making. Through an accessible visual programming language and an extensible scripting language, game maker accomplishes the task of easing the creation of 2D videogames. The latest available release as of this date, came in November 2020.

| STRENGTHS | WEAKNESSES |
|---|---|
| Accessible and Simple Interface | Lacking 3D support (possible if the user implements it) |
| Drag and Drop creation | Outdated Networking models |
| Wide availability of documentation and tutorials| Only Free Trial, yearly license per platform |
| Extensive Marketplace | Slower performance |
| Support for major platforms | |
| Strong tools for 2D game creation | |

<span class="pagebreak"></span>

!!! Tip: Game Examples
    Rivals of Aether (Dan Fornace LLC, 2015), Hyper Light Drifter (Heart Machine, 2016), Katana Zero (Askiisoft, 2019), Risk of Rain (Hopoo Games, 2013), VA-11 Hall-A (Sukeban Games, 2016), The Red Strings Club (Deconstructeam, 2018),...

### GDevelop

GDevelop<sub>[#W10]</sub> is an iniciative started by Florian Rival released in 2008, a game engine based on the web browser technology stack and capable of building for desktop and mobile platforms.

| STRENGTH | WEAKNESSES |
|---|---|
| Greatly Accessible, aimed at non-programmers | No 3D Support |
| Fully open sourced | Slow performance in bigger projects |
| Great documentation and focus on educational content | |
| Builds very easily to supported platforms | |
| Easy support for in-game monetization | |
| Includes game design tools | |
| Provides a complete subsystem package | |

!!! Tip: Game Examples
    Lil BUB's Hello Earth (Mike Bridavsky, 2019), Uphill Climb Racing Neon (Frolics2dio, 2021), Hyperspace Dogfights (Sleeper Games, 2018), Swamp(Afterapocalypse, 2019),...

### Cocos Creator

Cocos Creator<sub>[#W11]</sub> was originally the development environment for Cocos2d-x, was recently updated to support high performance 3D rendering pipelines (Vulkan and Metal), adding to their web based stack and native backends. Another fully open-source engine, initially published in 2010 by Zhe Wang, is a very accessible engine built upon Cocos2d by Ricardo Quesada, released in 2008.

| STRENGTHS | WEAKNESSES |
|---|---|
| High performance subsystems | Very young 3D tools |
| Fully open sourced backend | Slow to get updates |
| Lots of community support | |
| Supports multiple scripting languages | |
| Strong multiplatform support | |
| Easy integration of plugins | |
| Complete development package since 3D update | |

!!! Tip: Game Examples
    Imperial Saga (Square Enix, 2015), Rolling Cats (KingWorks, 2018), King Of Fighters Ultimate Match Online (DURPALM, 2018), Idle Heroes (DHGAMES, 2016), Revenge of Sultans (ONEMT, 2016),...

### Defold

Developed by Ragnar Scensson and Christian Murray in 2007 as a lightweight 2D game engine, was acquired by King in 2013. Initially as a licensed engine, in 2016 was released for free for any user and was later ceded to the Defold<sub>[#W12]</sub> Foundation in 2020, making the engine completely open-source. Support and investment will be continued by King.

| STRENGTHS | WEAKNESSES |
|---|---|
| Build for fast iteration | Small adoption |
| Support for desktop and major mobile platforms | Lesser availability of tutorials |
| Flexible scripting system | No visual programming tool |
| Strong focus on 2D, with 3D capabilities | |
| Easily Extensible | |
| Integration with popular ad and store platforms | |

!!! Tip: Game Examples
    Travel Blast (MP Games, 2020), Zoom-Be (Flazm, TBA), Interrogation (Critique Gaming, 2019), Fates of Ort (8bitskull, 2020), Family Island (Melsoft, 2019),...

<span class="pagebreak"></span>

### Lumberyard

In 2015, Amazon licensed CryEngine from Crytek in order to create an engine with native support for the Amazon Web Services (AWS), allowing developers to build and host their games on Amazon's servers. With the acquisition of Twitch, Lumberyard<sub>[#W14]</sub> also has integration with the Twitch Livestreaming API, allowing interaction with the viewers natively. It was publicly launched in 2016 and later made source-available<sub>[#W9]</sub>.

| STRENGTHS | WEAKNESSES |
|---|---|
| Big Company Backing | Owned by Amazon |
| Strong realtime online service and subsystems | Locked in their network solutions and servers |
| Fast update rate | Complicated onboarding process |
| Extensible C++ scripting and visual scripting | Slow IDE performance |
| High performance graphic inherited from CryEngine renderer | Unstable releases |
| Lots of examples, tutorials and documentation provided | Slow build times |
| Completely free for offline games | |

!!! Tip: Game Examples
    Star Citizen (Cloud Imperium Games, Never...), The Grand Tour Game (Amazon Game Studios, 2019), New World (Amazon Game Studios, 2021+), Coffence (Sweet Bandits Studios, 2018),... mostly TBA or canceled projects.

### Other Engines

There is a vast amount of both open and proprietary game engines out 
there, from fully featured to starting in the development process such as this thesis. As the reach for this project is limited it is not possible to delve into them, a list of engines and articles gathering and providing information about more engines is provided:

 * CUSTOM GAME ENGINES: A Small Study. Ramon Santamaria. <https://gist.github.com/raysan5/909dc6cf33ed40223eb0dfe625c0de74>
 * Diligent Engine. Diligent Graphics. <https://github.com/DiligentGraphics/DiligentEngine>

<span class="pagebreak"></span>

## SqueLib and SqueMaker as Resources

Both SqueLib and SqueMaker as tools fall in an already big and deep market as long as you're willing to look out for the tools and learn them. The market cap and current interests are probably well taken care of.

The described examples in competing markets provide vast amounts of features for both building applications, 2D or 3D, any platforms available and aimed at every level of experience. What is mostly lacking is a per subsystem approach to understanding the creation of said tools.

Neither SDL nor Rawdraw are introduction level friendly by themselves when targeting multiplatform projects, they require a very finicky initial setup or less accessible tools for getting it running. RayLib has a great deal of supporting examples and documentation for getting things to work almost everywhere, it should be the immediate go-to for someone coming from being a user of SqueLib.

SqueLib will not be a competitor or a replacement in the short run by any means, what it brings is a structured and educational approach to diversify a C++/Game Dev student programmer into a lower level and higher cost of entry programming environments.

Game engines provide mostly all the tools required to get things running, what I find missing is quick access to iterating over the tools available and creation of new tools. Each project has its own demands, having the flexibility of fleshing out the desired tool and having access to it as soon as possible is a missing piece of every game engine compared to custom engines.

SqueLib targets a quick and easy setup process to get a C++ graphic application running in Windows, Ubuntu Linux and Android. SqueMaker is both a testing environment for SqueLib as well as a simple tool for making simple cross-platform games and tools quickly.

This project as a whole, also aims to provide an introductory approach to the subsystem programming and decisions made for the development of the library, the engine and the applications created with them: open sourcing the research and development process of making such tools.

# Project Planning

The process of developing and refining a framework to build applications is a long task, no frameworks are instantly adopted and have the best entry user experience. There are programming and accessibility challenges that have to be tackled constantly.

It is crucial to maintain a strictly timed environment for tackling the multiple challenges faced.

Under **Section 3.1**, the tools used for managing the project in a high level way will be show. Then **Section 3.2** will provide the method for validating the results of each step of development.
On **Sections 3.3 through 3.5** a SWOT (strengths, weaknesses, opportinities and threats) analysis, fallback strategy and cost analysis are provided.

## Planification Tools

The following section will provide information about the tools used for initially planning the project, tracking the progress of each step and mantaining the project up to date and in working conditions at all times.

### Gantt Project

The first layer of planification is based on having the main areas of development, defining the required subsystems, examples and documentation steps for accomplishing each task. Instead of primarily defining all the task and steps to be taken, which will vary as time goes on and research on the topics is completed, its best to outline the planned steps.

A Gantt chart feels ideal to decide on timestamps for these tasks and their dependencies, the tool used will be Gantt Project<sub>[#W24]</sub>. The development plan is specified under **Figure 3** and **Figure 4**: 

![Figure [figures]: Library Development Plan](images/Gantt1.png)
![Figure [figures]: Engine Development Plan](images/Gantt2.png)

<span class="pagebreak"></span>

### HacknPlan

After checking out multiple tools around task management including Trello, Github Boards, Gitkraken Boards or even custom formats of Google Sheets, the tool I have personally found most useful and flexible has been HacknPlan<sub>[#W25]</sub> 
(**Figure 5**).

![Figure [figures]: Example HacknPlan Board used](images/HacknPlan_Board_Example.png)

A great part of the project consists of diving into new content not explored during these formative years, as such a lot of variables will come into place and the initial planning can't be really fully detailed. 

As such, a flexible task system was required to follow the initial plans and allowing flexible adjustment of tasks, from which both Trello and HacknPlan could be great options.

In the end, HacknPlan provides higher task control and its usage is not limited for free users.

### Version Control: Github and Gitkraken

Software projects are a sum of multiple blocks and constant iteration, during their process it is imperative to have a way to take note of the changes and actions performed. Using a version control system the project becomes easily portable and an easily accessible update log, which Github will be used as a public repository hosting service.

Even more important is the fact that the project will be tested and developed on multiple platforms, as such the Gitkraken<sub>[#W22]</sub> git GUI client will be used as it has Linux compatibility and some great features for managing repository branchs.

<span class="pagebreak"></span>

![Figure [figures]: Gitkraken Commit Form](images/GitKraken.png) 

Gitkraken is very simple and provides great functionality for understanding changes and avoiding pushing changes before reviewed. By default, changes are not staged for commiting, shown in **Figure 6**, but you can select manually which changes to set up for the next commit and review them before commiting them.



Repositories for the Library and Engine can be found under [#W1] and [#W2].

## Validation

Given that the final result is not only a user-oriented product but a development tool too, it is of most importance to keep stability on the designed workflows. As the success metrics of the project fall under ease of use and accessibility for C++ programmers, under **Figure 7** the development iteration approach is shown:

**********************************************************
*.------------------------.   .----------------.
*| Develop Implementation |-->| Create Example |--.
*'------------------------'   '----------------'  |
*           ^                         |           | 
*           |   Usability Iteration   |           |
*           '<------------------------'           |
*           |                                     |
*           |                                     |  
*     .---------------------. Easy+Stable Usablity|
*     | Write Documentation |<--------------------'
*     '---------------------'
*********************************************************
[Figure [figures]: Accessibility oriented development]

This simple procedure makes the intentions very clear. Getting implementation done and refined alongside a simple example are the first part of every subsystem. When developing different examples the true value of the implementation and its superficial flaws are found quickly, making it easier initially to get a more usable product.

As well as the iterative process of development, debug mode checks have been placed in the tool for the user to get notified of any misuses of the library and the errors committed with the implementation. This is explained under the library development section.

## SWOT Analysis

| STRENGTHS | WEAKNESSES |
|---|---|
| Previous experience in engine creation | Long development time with lots of content |
| 5 Years of Experience in C++ and experience in used libraries | Lack of experience with cross-platform tools and platforms other than Windows |
| Time and drive to try new things | No experience in state of the art C++ development |

| OPPORTUNITIES | THREATS |
|---|---|
| Entry to multiplatform C++ development is not straight forward, accomplishing a good entry for developers | There are lots of fully feature frameworks and engines one can go to and get faster and better results, as there's more support and documentation available |
| There's no financial risk as a student project | Time is extremely limited, the project will fall short on refinement for larger scale production |

<span class="pagebreak"></span> 

## Risks and Contingencies

Given the scope of the project, the most sensible approach is to identify where the principal choking points of the project lie and understand where to fall back from those possible stepbacks.

### Development Risks

| Development | Solution |
|---|---|
| Data corruption | Code and Thesis are being worked with version control systems, they can be recovered |
| Development Device failures | Development is done under a Windows and a separate Linux device, both capable, and access to another Windows device that could be setup for development. |
| Android Device Failure | There were initially 2 extra devices available, of which one has had issues. Now there is 1 extra available, all at the required minimum Android Version |
| Time Missplanning | Given the section below, tasks from the back will be cut in order, there is a planned month and 3/4 left for polish loop |
| Library / Software issues | Issues on platform and library are planned in time as well as expected deviation, buffer time for planning is available for learning time but at most it will fall to modules already developed in other libraries |

<span class="pagebreak"></span> 

### Planned Task Risks

The development process takes part in OSs that have not been previously explored with C++, as well as a plethora of tools that will be new to use and even find out about. Given the initial uncertainty of the project, a strong buffer of the main expected tasks has to be prepared.

| C++ On Linux | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Development Environment | 5 | 0% |
| Building | 4 | 25% |
| Debugging | 1 | 100% |

| C++ On Android | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Development Environment | 10 | 50% |
| Building | 10 | 100% |
| Debugging | 10 | 100% |

| Library Main Modules | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Display / Window Management | 10 | 10% |
| User Input | 10 | 100% |
| Graphics | 10 | 10% |
| File Access System | 5 | 40% |

| Main Library Examples | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Performance Tests | 2 | 500% |
| Pong | 2 | 50% |
| LearnOpenGL on Library | 6 | 0% |
| ImGui Example | 5 | 20% |

| Base Engine Development | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Engine UI System | 5 | 40% |
| ECS Structure | 5 | 100% |
| Render Pipeline | 10 | 50% |

| Project Documentation | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Initial Delivery | 10 | 0% |

| Feature Completing Engine | Expected Time (days) | Deviation Buffer | 
|---|---|---|
| Resource Management | 10 | 0% |
| Input System | 5 | 100% |
| Scripting System | 15 | 33% |

| Project Finalization | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Game Jame Time | 15 | 0% |
| Project Polish | 20 | 0% | 

Given the amount of uncertainty in the project, the final steps of the project are aimed at providing a feedback loop on it rather than expand on it. As most tasks involve a high level of uncertainty given unfamiliarity with the systems, this time serves as a buffer for most other tasks. These close to 2 months of finishing development can be reallocated to finishing features and making sure it is as user-accessible as possible.

<span class="pagebreak"></span>

## Cost Analysis

Although the project is aimed at producing open-source content, thus not having a financial reach in mind, the development time and resources have to be taken into account and make an approximated calculation of the costs:

### Monetary Costs

!!! note
    The average gross salary of a C++ programmer in Spain ranges from 22.000€ to 32.000€, for entry to mid-level positions on an open-ended and fulltime contract. This project would fall under a temporal contract, which is statistically paid 25% less<sub>[#W28]</sub>, as well as an entry-level position; a monthly salary of 1.375€ can be estimated.

![Table [tables]: Approximated costs over a 9 month long development time. Amortization time is divided through its expected amortization time and then multiplied by development time to get amortized cost.](images/Cost_Table.png)

# Methodology

Given the initial planning of the project, with previous knowledge of the lack of knowledge in the area, it is expected to have increasing requirements and tasks added to the backlog. Agile methodologies are extremely suited to rapidly changing environments, designating specific sprints for development and allowing for task flexibility in them.

There are multiple methodologies that have been developed from the Agile principles, as the project is developed by a single person it makes little sense on focusing on most methods that have been designed to coordinate group efforts. Having said that, a variable sprint approach to the Agile methodology (**Figure 8**) fit this project the most.

***************************************************************************
*        .----------------------------------------------------------.
*        |                      Positive Reception                  |
*        v                                                          |
*.--------------.   .------------.   .---------.   .------.   .----------.
*| Next  Sprint |-->| Plan Tasks |-->| Develop |-->| Test |-->| Feedback |
*'--------------'   '------------'   '---------'   '------'   '----------'
*                          ^             ^            |             |
*                          |             | Not Stable |             |
*                          |             '------------'             |
*                          |                                        |
*                          |           Negative Reception           |
*                          '----------------------------------------'
***************************************************************************
[Figure [figures]: Simplification of the Agile Process]

<span class="pagebreak"></span>

## Variable Sprint Agile

In Agile methodology, it is expected to have clear cut sprints through which things are performed and then they are passed down to the following sprints when failure to achieve occurs. Given the variability of the project and even the building blocks of it, an approach to a simplified Agile process without a specific task backlog is required.

### Sprints

Sprints take between two weeks and a month in the project, but the tasks inside are orientative rather than strict tasks, as such each sprint requires initial planning and research for task creation. After that, the Agile process takes place and used to continue development.

## Tracking Tools

In the planning phase of a sprint, the elements cut-off or non achieved from the previous sprint, which do not affect the next steps, are reflected upon and backlogged or added as active tasks. After categorizing non-finished tasks, a retrospective on what has made that happen is performed and noted for improvement in further sprints.

Under **Figures 9**, **10** and **11**, HacknPlans main user interface is detailed: 

![Figure [figures]: HacknPlan Board Example](images/HacknPlan_Board_Edited.png)

**HnP.1. Boards:** Under Boards, a list of folders (called Milestones) are located inside of which a number of boards can be created to separate the different sprints. In the current one, we are at *TFG 1st Delivery* Milestone under the *Rubrica 1* Board.

**HnP.2. Task Types:** In order to facilitate navigation of task types, you can select which ones to have visible. In this project, 99% of the tasks are programming based so in my case organizing them becomes more cumbersome than useful. In other projects that involve bigger teams and disciplines, it is a must tool.

<span class="pagebreak"></span>

**HnP.3. Current Board Options:** First the Board Name, then the task creation and finally a button to the information pertaining the board.

**HnP.4. Board Task Management:** Where the tasks are created and can be seen, moved and edited according to the users doing them.

![Figure [figures]: HacknPlan Task Example](images/HacknPlan_Task_Edited.png)

**HnP.5. Task Stats:** In order, displays the information added to the tasks, be it attachments, subtasks, comments, work logs,...

<span class="pagebreak"></span>

![Figure [figures]: Add Menu](images/HacknPlan_AddMenu.png) **HnP.6. Addition Panel**: Under this panel appears the available options for adding information to each task.

* **User**: Link to participants of a board (teams).
* **Tag**: Sometimes the base descriptors are not enough, custom tags available.
* **Subtask**: Add a subtask window for tracking simple small steps for the task.
* **Comment**: Write a message for specific moment information on the task.
* **Dependency**: Link to another task, blocking it until completion of said tasks.

**HnP.7. Log Work:** After doing work for a task, it is recommended to log how much time it is spent in order to not just track expectations after each sprint, but also allows instant commenting of that session which is great for getting back on exact track when coming back to a task.

**HnP.8. Task Information Window**

**HnP.9. Sub-Task Window:** As most tasks are completed dynamically, this becomes very handy for tracking quick subtask that would pollute the visibility in task names or generate too small of tasks that pollute the board.

**HnP.10. Comment Window:** After logging work, a comment is created with that session information. Imperative for both teams and individuals participating in each task.

<!-- RUBRICA 2 - WIP -->

# Development Plan

Before delving deep into development, it is important to make clear cut decisions on how to approach each area and define the building blocks for the subsequent projects. The following sections will give an insight to the initial decisions as well as the ongoing development process of ***SqueLib*** and ***SqueMaker***.

## CMake

In the context of multiplatform development, there is a ton of options of IDEs and building pipelines to choose from. The experience gained previously from only working with Visual Studio for C++ can seem approachable in a cross-platform point of view, as there are a lot of base projects and extensions available for targetting popular platforms such as Android and Linux. The main problem in going back into Visual Studio is not branching into other editors and build pipelines.

Visual Studio supports CMake based projects, but for the sake of progressing as well learning new tools for the trade, starting first from CMake and then using Visual Studio for specifically Windows development seems the best fit. Further explanation on the usage of CMake is provided in the following chapter.

<span class="pagebreak"></span>

## SDL, RayLib and Rawdraw

Both SDL<sub>[#W19]</sub> and RayLib<sub>[#W20]</sub> are the contemporary standards for easier C and C++ open-source game development libraries, in many people's point of view including mine. Both offer a ton of content, documentation, examples and tutorials for close to every platform possible. The approach of this thesis is directly inspired by these libraries but giving an insight to what is required to accomplish their purpose. When developing specifically for portability and facilitating iteration times, both libraries are the most versatiles out there, both with great community support specially RayLib by getting constant updates and support for more platforms and programming language bindings. 

Besides eliminating the practical approach to developing a cross-platform library when using any of those as a base, the way things are handled when building for Android seem a bit outdated as of the latest releases available for both, where more straightforward approaches would help in the development for that platform.

Rawdraw on the other hand has a more "you do you" approach, just source code and a single example is available and its intended use (besides as a library) is that of learning. Being a C library and the compiler toolchain being way less entry level friendly, I decided to take it as a base for learning the steps to introducing myself but making it easier for a future self to do this introduction.

## Base Modules' Libraries

An introduction to the library or framework will be provided, as well as the reasons provided for its usage, or lack of it:

### Rendering Graphics: OpenGL and OpenGLES

OpenGL<sub>[#W16]</sub> is a cross-language API for rendering both 2D and 3D raster graphics, targeting the GPU in order to have hardware-accelerated rendering. Initially released in 1992 by Silicon Graphics Inc., it has been receiving first party support until 2017 with the 4.6 release, being developed by the Khronos Group since 2006.

While taking part in the Degree in Design and Development of Videogame, OpenGL has been the staple graphics API used for most projects alongside WebGL and SDL wrappers. Given that experience it was a quick decision to use such a library that is cross-platform capable for the targeted platforms.

OpenGLES<sub>[#W17]</sub> is a cut down version for embedded devices such as mobile phones, having almost the same syntax for most operations besides what is or not available and minimal changes in shader language syntax, making it a faster inclusion than targeting other graphics API for Android.

The latest available official release of OpenGLES, version 3.2, is the one that mirrors core OpenGL syntax the most, allowing for further simplicity in writing a portable OpenGL backend. A counterargument to deciding on said version of OpenGLES would be that it does not cover enough devices, which as of checking would be at around 68%<sub>[#W34]</sub> which I personally think is plenty and will only be increasing with time. Having said that, my focus is not on targeting content consumers but developers that after being introduced could very well adapt a different rendering pipeline with earlier versions of OpenGLES.

As it is a cut down version, as well as an older one, there are still some compatibility issues with newer core versions. For that reason, core version 3.3 will be used because the GLSL syntax is the most similar as well as being the step closest to contemporary core OpenGL which I am more familiar with.


The remaining differences between versions will be circumvented as how cross-platform issues should be dealt with, by writing backend specific code.

### Context Management: EGL and GLFW

In order to display graphics on screen, it is required to have a canvas in which to draw, called Context for some graphics APIs. EGL<sub>[#W15]</sub> is a cross-platform interface between the Khronos Group rendering APIs and the OSs' windowing systems in order to allow the display of graphics.

The use case in context management for both libraries is to take care of binding of surfaces and buffers to write to, synchronization of the rendering with the displays and enabling the acceleration of such operations with the underlying hardware.

GLFW<sub>[#W18]</sub> has more functionality in creation of windows and taking care of input, the catch is that it is only available in desktop platforms. EGL is a native library to Android, which creates the first platform divide for taking care of different subsystems.

### User Input: GLFW and Android NDK

The big issue when handling user input between the proposed platforms is that they are completely different. Android input is touch based and in desktop platforms the keyboard and mouse combo are the most widely used. They are by no means incompatible but by default there are not many options that take care of them in a similar fashion. It was a clear area where a new cross-platform approach was needed.

The Android NDK<sub>[#W21]</sub> is the provided API by Google in order to interact with Android devices in native C and C++ code. Most interaction to Android requires calling from Java environments, the NDK provides JNI, a Java Native Interface through which accesses the native systems. These native systems include the main input system.

GLFW takes care of user input in desktop environments on a per window basis, meaning that you can set up direct access to what the user performs and receive that information when needed in each window created.

### File Access: Native through C++ STL and Android NDK

When developing games, getting hold of files is pretty straightforward, you have to load them into memory and then perform any complicated operations with other methods, the same way to write files to the system. 

On Android subsystems the user does not have direct write access, special permissions are required and as such specific functions are required from the NDK in order to access and write files. In desktop environments, using plain C++ is the most straightforward way alongside some OS provided standard libraries.

The meat of this system is to make it truly platform agnostic to the end user.

## Libraries Not Used

It is important to remark that there are many other open-source alternatives to most of the libraries that have been used or will be used for the main subsystems of this project. While the great majority are not covered here, most either could be interchangeable or require a lower level understanding of the required subsystem.

The information on the unused libraries are simple reasons on why they were not used, with unfamiliarity being one of the main reasons not to delve too deep into them due to strict timelines.

| Graphics APIs | Reason |
|---|---|
| Magnum Engine | Unfamiliarity and few entry level documentation |
| Vulkan | Unfamiliarity and oriented to much lower level programming |
| Ogre | Unfamiliarity and provides much more features for animation, scene, effects,etc, which are not required, bloating the project initially with higher entry cost |
| Direct3D/DirectX | Support limited to Windows / Universal Windows Platform |

| Context Management | Reason |
|---|---|
| WGL | Windows only support |
| GLEW | Could have been an interchangeable option, but extensions are supported differently in Android, incompatible with OpenGLES |

!!! note
    Most context management libraries take only part in generating the OpenGL context, as they should, leaving more work into taking care of managing windows through the native systems on Windows and Linux. Although in Windows that would have been more straightforward, due the high variance between distros in Linux, that would have been a great time cost.

| Input Libraries | Reason |
|---|---|
| Gainput | Outdated Android toolchain, would have had a lot of costs for building on current versions |

!!! note
    For taking care of accessing files, the only one that I have had previous experience is PhysFS which has fallen out of use in recent years. Given the approach of the project it did not seem fitting to use it as it would tie more dependencies to structuring data, which is already complicated enough for Android.

# Introduction to Cross-Platform C++

Being set up with the initial research on the project statement and values, the first step is to be able to get code working on all target platforms, as well as generating a comfortable framework from to which develop the subsequent projects.

It is very evident that having multiple code bases per platform and having to use wildly different environments for getting code to run on the target platforms is a big issue to tackle. The most sensible approach would be to have a way to just execute what is needed on a bunch of source files and get the resulting application ready to run, the less input from the user to get it working the better.

<span class="pagebreak"></span>

## CMake: Building for multiplatform 

CMake is a generator of build files, when you build a project with CMake you are first creating the files that the target building environment will use to create the final application. In that way you can create a environment agnostic step that will then be converted to the one needed for each platform you target.

![Figure [figures]: CMake Simple Flowchart, from [How to Build a CMake based Project](https://preshing.com/20170511/how-to-build-a-cmake-based-project/) by Jeff Preshing.](images/cmake-simple-flowchart.png width="50%") Following **Figure 12**, CMake is invoked in a directory where a CMakeLists.txt script is, which will prepare a configuration for the desired outputs. Said configuration will be cached for later runs.

In each CMakeLists.txt there are a series of outputs defined, called targets, that hold the specific information required to be built into their executable form. Such information might be source files, instructions, compiler/linker, etc.

The configuration step ends up with the build files required by the specific build system used (XCode, GCC, MSVS,...), who will actually build the executables. 

### Simplest Expandable Example

Under **Figure 13**, the base layout of the folder which will be expanded upon, is set: 

***********************************************
* ./SourceFolder                              *
*       |                                     *
*       '---/CMakeLists.txt                   *
*       |                                     *
*       '---/main.cpp                         *
***********************************************
[Figure [diagram]: Base Folder Structure]


From unique previous knowledge of building C++ aplication through Microsoft Visual Studio, the best way to get into new ways is to learn from the simplest possible example required. With that virtue, the starting file to work on would be the following main which would only print out _Hello World!_ to a console to make sure everything is working as intended.

<span class="pagebreak"></span>

**_main.cpp_**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C++ linenumbers
#include <cstdio>
int main(char** argv, int argc)
{
    printf("Hello World!");
    return 0;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Following the main source code, the simplest way to build with CMake is:
 1. Specifying a version
 2. Setting up a project
 3. Defining a target
 4. Declaring where the header files are
 5. Explicitly tell what source files to add.

**_CMakeLists.txt_**
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash linenumbers
cmake_minimum_required(VERSION 3.1)
project(CMakeExample LANGUAGES CXX)
add_executable(CMakeExample)
target_include_directories(CMakeExample PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
target_sources(CMakeExample PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/main.cpp) 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally on command line, tested initially from Windows:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash linenumbers
cmake . 
cmake --build .
./Debug/CMakeExample.exe # Default configuration for MSVS is Debug
_Hello World!_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Cleaning Up Simplest Example

![Figure [figures]: Source folder after building the project](images/cmake_folder_bad.png width="30%") In **Figure 14**, we can see that the folder structure after building a CMake Project becomes a mess, it will create the necessary build files for the target generator, in this case MSVS. 
The build will be created where the CMakeLists.txt defines. After understanding how to clean that, the simplest way would be creating a directory from where CMake executes and generates files inside the source folder and setup the target to build in a specific directory.

**_CMakeLists.txt_** - Change where the build files go to
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
set(OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/builds)
set_target_properties(CMakeExample
    PROPERTIES
        ARCHIVE_OUTPUT_DIRECTORY ${OUTPUT_DIRECTORY}
        LIBRARY_OUTPUT_DIRECTORY ${OUTPUT_DIRECTORY}
        RUNTIME_OUTPUT_DIRECTORY ${OUTPUT_DIRECTORY})
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<span class="pagebreak"></span>

Then on Command Line we create a folder to execute from, then call cmake to build the parent directory:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash linenumbers
mkdir -p ./CMakeFiles # Create a directory for cmake
cd CMakeFiles # Navigate there
cmake ../ # Call CMake on the previous directory
cmake --build .
../builds/Debug/CMakeExample.exe # executable is now on builds for
_Hello World!_
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally on **Figure 15** we can see that now the source folder becomes visibly cleaner and manageable once again:

![Figure [figures]: Cleaner folder structure.](images/cmake_folder_good.png)

## C++ on Android

The previous part introduced CMake in a way that works very easily with a console based application and nothing more to execute. On such desktop platforms, usually you don't have to worry too much about how you package your data, assets or libraries as long as are reachable from working directory or provided by the vendor. There is not actually a required way to package or build your application besides making sure it works.

In order to build Android application, the usual way would be to build them using the designed tool for the task and native programming language. In that case we would be writing a Java/Kotlin application from Android Studio, but my requirement was to just code in C++ as to minimize the entry requirements for someone with a similar background to me, while giving an approach that opens up new development paths.

Parallel to the main tool, Google provides the Android SDK which has a suite of tools for compiling, packaging, debugging and many more things for Android projects with external toolchains such as CMake. With that in hand, one can provide their own way of compiling the source code as well as generating the necessary files required for a complete packaged app, then use the tools to finalize the process, install and run the application on the target Android device.

<span class="pagebreak"></span>

A big concern of mine was having to delve too deep into new ways of building a project, tools and even languages, while still maintaining the capability of using the tools I am used to or found in OSS. ***Rawdraw***<sub>[#W26]</sub> for Android is what drove me away from Visual Studio only development and more toward other options. Rawdraw is a graphics rendering and building framework for developing extremely portable applications written in C. 

The presentation video<sub>[#W30]</sub> showing the portability to Android mentioned the unique requirement of writing C and modifying the build file. Given those premises and the fact the Android SDK comes with a C++ interface together with the C interface, the Android NDK, it became the starting point for development.

On the following steps, it will be explained the adaptations from Rawdraw Make build system to CMake, as well as making the minimal example run on Android OS.

### Adapting Rawdraw Make build to CMake 

In short words, Make is similar to grouping a bunch of scripts under functions and being able to call them as needed. Instead of having to build from command line doing every step you write a script that has the required steps given some inputs, like a function, and then executes these steps when calling the said function.

***Makefile Example: Creating the minimum items required for a template project***
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash linenumbers
create_base_folders:
    mkdir -p ./source
    mkdir -p ./include
    mkdir -p ./assets
    mkdir -p ./builds

create_base_files:
    touch README.md
    touch LICENSE

# Functions can call other ones as arguments/dependencies
init_project: create_base_folders create_base_files 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
# Creates the base folders and files for a project
make init_project 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

CMake will be used in this case to generate Makefiles through which to build the final application, benefitting from Rawdraw's targets<sub>[#W51]</sub> by translating into CMake code. The generation and build steps are strictly separated as some parts are required by the CMake generation step and also required at build time. The variables or steps required at generation step will be converted into macros, that define global variables and paths accessible from the build step, which is translated into custom CMake targets.

The following steps will provide insight on the modules in which the steps are divided to perform the build step for Android.

#### _SqueLib_Android.toolchain_

The first step to getting a build working specifically for Android is setting the environment variables properly. CMake makes uses of toolchain files in order to setup variables that are invariably linked to every target built, such as the compiler.

When making a call to CMake from command line, said file must be passed to the `CMAKE_TOOLCHAIN_FILE` variable. As the Android NDK provides a modified script depending on the targeted Android version<sub>[#52]</sub>, the variable `ANDROID_VERSION` is added as a requirement for Android building on SqueLib.

Because on Windows and Linux it is intended by the library for CMake to find the default compiler options given the generator options, the toolchain will be limited to Android. In any case, a toolchain could be written and passed instead with user specific options as well as changing compiler and linker flags on each target.

As the toolchain is made of a single file, it will be explain in the following parts: Helpers, Environment Variables and Setting up Compiler.

##### Helpers

In order to have less requirements for the user in terms of what to do in order to get going, a couple helpers are thrown to find directories and files easier. Both are used in the next stage for setting up the Environment Variables.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
# Get a list of Subdirectories from a Current Directory
function(subdirlist result currdir)
    message(STATUS)
    message(STATUS "subdirlist()")
    file(GLOB children RELATIVE ${currdir} ${currdir}/*)
    set(list "")
    foreach(child ${children})
        if(IS_DIRECTORY ${currdir}/${child})
            message(STATUS "Added ${child} to list")
            LIST(APPEND list ${currdir}/${child})
        endif()
    endforeach()
    set(${result} ${list} PARENT_SCOPE)
    message(STATUS)
endfunction()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<span class="pagebreak"></span>

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
# Get the first directory that exists in a list of items
function(first_exists result list)
    message(STATUS)
    message(STATUS "first_exists()")
    message(STATUS "Checking: " "${list}")
    set(found "")
    foreach(item ${list})
        message(STATUS ${item})
        if(IS_DIRECTORY "${item}/")
            message(STATUS "${item} Exists!")
            set(found ${item})
            break()
        endif()
    endforeach()
    message(STATUS "Check ${found}")
    set(${result} ${found} PARENT_SCOPE)
    message(STATUS)
endfunction()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

##### Environment Variables

The next step is to find the directories and variables required to interface, as it is englobed in a single macro because it makes sense to get these variable out in one go as well as having them available for the whole CMake project afterwards, the explanation will be divided step by step in the macro ***setup_android_sdk_vars***:

The OS string required to where the build, header and library files are specified at the Overview<sub>[#W35]</sub> page for external build systems.

~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
# Assume from Linux, else change OS Android naming to Windows.
set(OS_NAME linux-x86_64)

if(WIN32)
    set(OS_NAME windows-x86_64)
endif()

message(STATUS "Building from " ${OS_NAME})
~~~~~~~~~~~~~~~~~~~~~~~~~~

Then it is required to find the directory in which the SDK, NDK and Build Tools are placed. The helper functions are used when no Android arguments or Environment variables are set:

~~~~~~~~~~~~~~~~~~~~~~~~~~bash
if(NOT ANDROIDSDK)
    set(SDK_DIRS $ENV{SDK_LOCATIONS} $ENV{ANDROID_HOME} $ENV{ANDROID_SDK_ROOT} ~/Android/Sdk $ENV{HOME}/Android/Sdk c:/dev/AndroidSDK c:/src/AndroidSDK c:/AndroidSDK)
    first_exists(ANDROIDSDK "${SDK_DIRS}")
endif()
~~~~~~~~~~~~~~~~~~~~~~~~~~

<span class="pagebreak"></span>

~~~~~~~~~~~~~~~~~~~~~~~~~~bash
# Search for NDK inside SDK
if(NOT NDK)
    if($ENV{NDK})
        message(STATUS "NDK already defined at ${NDK}")
        set(NDK $ENV{NDK})
    elseif($ENV{ANDROID_NDK})
        message(STATUS "NDK already defined at $ENV{ANDROID_NDK}")
        set(NDK $ENV{ANDROID_NDK})
    elseif($ENV{ANDROID_NDK_HOME})
        message(STATUS "NDK already defined at $ENV{ANDROID_NDK_HOME}")
        set(NDK $ENV{ANDROID_NDK_HOME})
    else()
        set(NDK_DIRS ${ANDROIDSDK}/ndk ${ANDROIDSDK}/ndk-bundle)
        first_exists(NDK_G "${NDK_DIRS}")
        subdirlist(NDK_L ${NDK_G})
        first_exists(NDK "${NDK_L}")
    endif()
endif()

# Search for Build Tools inside SDK
if(NOT BUILD_TOOLS)
    first_exists(BT_EXISTS ${ANDROIDSDK}/build-tools)
    if(NOT EXISTS ${BT_EXISTS})
        message(FATAL_ERROR "Build tools folder not found")
    endif()
    subdirlist(BT_Vrs ${BT_EXISTS})
    first_exists(BUILD_TOOLS "${BT_Vrs}")
endif()
if(NOT AAPT)
    set(AAPT ${BUILD_TOOLS}/aapt)
endif()
~~~~~~~~~~~~~~~~~~~~~~~~~~

A specific case in the build tools is ADB, because when working through the WSL you can invoke the Windows version of ADB to get access to the host Windows machine USB ports to interface with your physical device but not from the Linux ADB inside the WSL distro.

As the previous tools, should it be not defined then it will setup the default installation paths.

~~~~~~~~~~~~~~~~~~~~~~~bash
if(NOT ADB)
    if(WSL)
        set(ADB ${ANDROIDSDK}/windows/platform-tools/adb.exe)
    else()
        set(ADB ${ANDROIDSDK}/platform-tools/adb)
    endif()
endif()
~~~~~~~~~~~~~~~~~~~~~~~

Finally a couple debug messages to make sure everything is working as intended, and then print the found locations. Should any directory be missing, the build process must stop.

<span class="pagebreak"></span>

~~~~~~~~~~~~~~~~~~~~~~~bash
# Check that everything was found
if(NOT EXISTS ${ANDROIDSDK})
    message(FATAL_ERROR "ANDROID SDK NOT FOUND")
endif()
if(NOT EXISTS ${NDK})
    message(FATAL_ERROR "ANDROID NDK NOT FOUND")
endif()
if(NOT EXISTS ${BUILD_TOOLS})
    message(FATAL_ERROR "ANDROID BUILD_TOOLS NOT FOUND")
endif()

message(STATUS ${ANDROIDSDK})
message(STATUS ${NDK})
message(STATUS ${BUILD_TOOLS})
message(STATUS)

~~~~~~~~~~~~~~~~~~~~~~~~~~~

##### Setting up the Compiler

When working with any compiler, there are a couple options that might be ideal to setup, as well as the need to specify which compiler tool to use.

In the Android NDK, there are already commands provided for calling the compiler properly depending on the minimum target version of Android but not really about the compiler and linker options.

There are various ways to setup global linker and compiler options, and they depend mostly on what one thinks is correct or not, but specifically for Android there are a couple that are needed as well as recommended. These will be listed down here with a short explanation:

***Compiler Flags [#W37]: CMAKE_C_FLAGS / CMAKE_CXX_FLAGS***
~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
NEEDED
 * -m64: Target a 64bit architechture.

RECOMMENDED
 * -fPIC: force Position Independent Code, meaning that there are no issues if the code is loaded in a memory addresses different than set from file (if they are specified).
 * -O3/O0: Optimization level, my defaults are 3 (max optimization) for Release and 0 for Debug (force keep all debug symbols). There are other levels, some times it is recommended Osize, which is similar to O2 with specific to make the binary smaller.
 * -ffunction-sections: Set each function to have a specific section when compiled into binary form.
 * -fdata-sections: Set each variable and structure to have a specific section when compiled into binary form.
~~~~~~~~~~~~~~~~~~~~~~~~~~~

These two last options are required for enabling garbage collection of unused data and functions, as well as possibly minimally increasing performance at the cost of minimally increasing binary size and compile times. For a better explanation of said options I refer to the posts [#W38] and [#W39] about these and other options.

***Linker Flags [#W36]: CMAKE_EXE_LINKER_FLAGS / CMAKE_SHARED_LINKER_FLAGS***
~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
NEEDED
 * -shared: Make sure the target is compiled into a shared library, which is needed for Android Native App linking.
 * -uANativeActivityOnCreate:  Undefine default ANativeActivityOnCreate definition to be replaced with the one coming from the Android NDK, making the application entry towards your own defined "android_main"

RECOMMENDED
 * -Wl: Activates linker warnings
 * -dead_strip / --gc-sections: Enables garbage collection for unused functions/data which may reduce binary size significantly. --gc-sections is specific to GCC, -dead_strip is for clang but also -fdce and I can but I could not find 1 to 1 documentation for clang
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally one has to set the target compiler for the languages. In CMake these variables have the form of `CMAKE_LANG_COMPILER` and they refer to the path towards the script to initiate the build process. That can be directly the executable or a script that gathers the data passed by CMake and performs the steps to properly call the compiler. In this case, we call the script provided by the Android NDK:

~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
set(CMAKE_C_COMPILER "${NDK}/toolchains/llvm/prebuilt/${OS_NAME}/bin/aarch64-linux-android${ANDROID_VERSION}-clang")
set(CMAKE_CXX_COMPILER "${CMAKE_C_COMPILER}++")
if(WIN32)
    set(CMAKE_C_COMPILER "${CMAKE_C_COMPILER}.cmd")
    set(CMAKE_CXX_COMPILER "${CMAKE_CXX_COMPILER}.cmd")
endif()
~~~~~~~~~~~~~~~~~~~~~~~~~~~

#### _SetupAndroidEnv.cmake_

In order to get access to the Android NDK, one has to link and include the Android libraries as well as the provided ones such as OpenGLES, Vulkan, OpenSL, etc. Finally, a couple variable names are set for the packaging step.

##### set_app_properties(appName orgName androidVer)

There are some variables that are of general use in other steps as well used in later custom targets for the packaging step, for this reaseon they are set during the build process as they depend on the target application.

<span class="pagebreak"></span>

~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
set(APPNAME '"${appName}"')
set(ORG_NAME "${orgName}")
set(LABEL ${appName})
set(APKFILE "${appName}.apk")
set(PACKAGENAME "org.${orgName}.${appName}")
set(ANDROIDVERSION ${androidVer})
set(ANDROIDTARGET ${androidVer})
~~~~~~~~~~~~~~~~~~~~~~~~~~~

##### link_android_libc(target)

Android does not provide a native C++ standard library for C++11 up, but the NDK does so with LLVM's LibC++, which can target up to a subset of C++17.

For that, this step has to copy into the library folder where the other shared libraries will be built into, then link it to the user application.

~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
set(ARM_LIBS ${NDK}/toolchains/llvm/prebuilt/${OS_NAME}/sysroot/usr/lib)
execute_process(COMMAND cp ${ARM_LIBS}/aarch64-linux-android/libc++_shared.so ${LIB_DIR})
set(LIBLINK ${ARM_LIBS}/aarch64-linux-android/${ANDROID_VERSION})
target_link_libraries(${target} PUBLIC ${LIBLINK}/../libc++_shared.so)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

##### link_android_all_libs(target)

Given a target to to build, link to the libraries required for development of a default application, needing: Display, Rendering, Sound, Standard Library, ADB Logging and the Android Library.

~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
set(ARM_LIBS "${NDK}/toolchains/llvm/prebuilt/${OS_NAME}/sysroot/usr/lib")
set(LIBLINK "${ARM_LIBS}/aarch64-linux-android/${ANDROID_VERSION}")
target_link_libraries(${target} PUBLIC 
    "${LIBLINK}/libm.so"
    "${LIBLINK}/libnativewindow.so"
    "${LIBLINK}/libandroid.so"    
    "${LIBLINK}/libEGL.so"
    "${LIBLINK}/libGLESv3.so"
    "${LIBLINK}/liblog.so"
    "${LIBLINK}/libOpenSLES.so"
    atomic
)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Linking directly to a specific library can be done using a similar function adapted to the libraries need, for SqueLib, linking to said items was the minimum necessary.

##### include_android(target NDK_PATH OS_USED)

Given a target to build, include the directories where the Android library include files are as well as the native app library.

<span class="pagebreak"></span>

~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
set(NDKINCLUDE "${NDK_PATH}/toolchains/llvm/prebuilt/${OS_USED}/sysroot/usr/include")
target_include_directories(${target} PUBLIC 
    ${NDKINCLUDE}
    "${NDKINCLUDE}/aarch64-linux-android"
    "${NDK_PATH}/sources/android/native_app_glue"
    "${NDK_PATH}/sources/android/cpufeatures"
)
~~~~~~~~~~~~~~~~~~~~~~~~~~~

#### _AndroidInstallTargets.cmake_

Finally, packaging and installing an applicaiton into a physical Android device is divided in different steps that should not be invoked from the CMake generation step. Instead, it is after the build step is performed that the user should call them after the intended application target is built.

This can be done by specifying the intended target to build first and then the required steps, or call make after calling a default build from cmake which will target directly the last target defined.

~~~~~~~~~~~~~~~~~~~~~~~~~~bash
cmake --build <dir> -target "AppName" -target uninstall -target install

OR

cmake --build <dir>
make uninstall install
~~~~~~~~~~~~~~~~~~~~~~~~~~

The documentation for generating custom commands in CMake can be found at [#W40] but here is the gist of my usage:

~~~~~~~~~~~~~~~~~~~~~~~~~~bash
add_custom_target("name_of_target"
    DEPENDS 
        Other_Targets
        ...
    COMMAND List_of_commands_to_execute
    ...
)
~~~~~~~~~~~~~~~~~~~~~~~~~~

Each target will have a short explanation, a list of dependencies if there are and a list of commands to execute to complete the target:

##### AndroidManifest.xml

In order to describe the essential information of an Android application, each app requires an _AndroidManifest.xml_ file. Although the NDK provides samples for creating one, Rawdraw provides an already templated one to which close no changes were made.

<span class="pagebreak"></span>

~~~~~~~~~~~~~~~~~~~~~~~~~~xml
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<manifest 
    xmlns:tools="http://schemas.android.com/tools" 
    xmlns:android="http://schemas.android.com/apk/res/android" 
    package="${PACKAGENAME}">
	
    <uses-sdk 
        android:minSdkVersion="${ANDROIDVERSION}"
        android:targetSdkVersion="${ANDROIDTARGET}"/>
    
    <uses-permission android:name="android.permission.SET_RELEASE_APP"/>
    <!-- permissions should be asked for in runtime -->

    <style name="SplashTheme" parent="Theme.AppCompat.NoActionBar"></style>
    <!-- make the application not show a titlebar when loading  -->
    <application 
        android:debuggable="${DEBUGGABLE}" 
        android:hasCode="false" 
        android:label="${LABEL}" 
        tools:replace="android:icon,android:theme,android:allowBackup,label" 
        android:icon="@mipmap/icon">
        
        <activity 
            android:configChanges="keyboardHidden|orientation" 
            android:label="${LABEL}" 
            android:name="android.app.NativeActivity">
            
            <meta-data 
                android:name="android.app.lib_name" 
                    android:value="${APPNAME}"/>
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>        
    </application>
</manifest>
~~~~~~~~~~~~~~~~~~~~~~~~~~

The target removes a previous instance of the manifest document, creates a copy of a template manifest provided and substitutes the environment variables setup<sub>[#W41]</sub>.

~~~~~~~~~~~~~~~~~~~~~~~~~~bash
COMMANDS
    rm -rf ${CMAKE_BINARY_DIR}/makecapk/AndroidManifest.xml
    cp ${SqueLib_defaults}/AndroidSpecific/AndroidManifest.xml.template ${CMAKE_BINARY_DIR}/makecapk
    PACKAGENAME=${PACKAGENAME} 
    ANDROIDVERSION=${ANDROIDVERSION} 
    ANDROIDTARGET=${ANDROIDTARGET} 
    APPNAME=${target}
    LABEL=${LABEL}
    DEBUGGABLE=${debuggable}
    envsubst '$$ANDROIDTARGET $$ANDROIDVERSION $$APPNAME $$PACKAGENAME $$LABEL $$DEBUGGABLE' 
            < ${CMAKE_BINARY_DIR}/makecapk/AndroidManifest.xml.template 
            > ${CMAKE_BINARY_DIR}/makecapk/AndroidManifest.xml

    rm -rf ${CMAKE_BINARY_DIR}/makecapk/AndroidManifest.xml.template
~~~~~~~~~~~~~~~~~~~~~~~~~~

##### makecapk.apk

Packs<sub>[#W42], [#W44]</sub> and signs<sub>[#W43], [#W45]</sub> the application into an Android recognized format (APK). During the process, some intermediate files are created and removed (_rm -rf_ command).

<span class="pagebreak"></span>

One specific thing that is not done in this step but part of the CMake build is packaging the resources. Because in desktop platforms, usually the relative path sits directly on the working directory but in Android there is a specific folder structure for the package, assets, resources and metadad.

On Android, such directiories are _/assets_ and _/res_ (resources). Resources are data required by the package whereas Assets are custom data used by the application, which can be loaded but not modified or written to.

~~~~~~~~~~~~~~~~~~~~~~~~~~bash
DEPENDENCIES
    AndroidManifest.xml

COMMANDS
    rm -rf ${CMAKE_BINARY_DIR}/temp.apk
    @echo "Packaging application..."
    ${AAPT} package -f -F ${CMAKE_BINARY_DIR}/temp.apk -I ${ANDROIDSDK}/platforms/android-${ANDROIDVERSION}/android.jar -M ${CMAKE_BINARY_DIR}/makecapk/AndroidManifest.xml -S ${CMAKE_BINARY_DIR}/makecapk/res -A ${CMAKE_BINARY_DIR}/makecapk/assets -v --target-sdk-version ${ANDROIDTARGET}
    unzip -o ${CMAKE_BINARY_DIR}/temp.apk -d ${CMAKE_BINARY_DIR}/makecapk
    rm -rf ${CMAKE_BINARY_DIR}/makecapk.apk
    @echo "Compressing into apk..."
    cd ${CMAKE_BINARY_DIR}/makecapk && zip -D9r ${CMAKE_BINARY_DIR}/makecapk.apk .
    @echo "Signing apk..."
    jarsigner -sigalg SHA1withRSA -digestalg SHA1 -verbose -keystore ${KEYSTOREFILE} -storepass ${STOREPASS} ${CMAKE_BINARY_DIR}/makecapk.apk ${ALIASNAME}
    rm -rf ${CMAKE_BINARY_DIR}/${APKFILE}
    @echo "Aligning apk..."
    ${BUILD_TOOLS}/zipalign -v 4 ${CMAKE_BINARY_DIR}/makecapk.apk ${CMAKE_BINARY_DIR}/${APKFILE}
    rm -rf ${CMAKE_BINARY_DIR}/temp.apk
    rm -rf ${CMAKE_BINARY_DIR}/makecapk.apk
~~~~~~~~~~~~~~~~~~~~~~~~~~

##### uninstall

Remove the application from the physical device. Nothing happens if the application is not already installed.

~~~~~~~~~~~~~~~~~~~~~~~~~~bash
COMMANDS
    COMMAND @echo "Uninstalling " ${PACKAGENAME}
    -${ADB} uninstall ${PACKAGENAME}
~~~~~~~~~~~~~~~~~~~~~~~~~~

##### push

Install the application on the target device.

~~~~~~~~~~~~~~~~~~~~~~~~~~bash
DEPENDENCIES
    makecapk.apk
COMMANDS
    @echo "Installing " ${PACKAGENAME}
    ${ADB} install -r ${CMAKE_BINARY_DIR}/${APKFILE}
~~~~~~~~~~~~~~~~~~~~~~~~~~

##### cleanup

Explicitly remove all temporary files.

~~~~~~~~~~~~~~~~~~~~~~~~~~bash
COMMANDS
    @echo "Cleaning temporary files..."
    -rm -rf temp.apk makecapk.apk makecapk ${APKFILE}
~~~~~~~~~~~~~~~~~~~~~~~~~~

### Adapting the Minimal Example source code for Android

Following the Android NDK Examples<sub>[#53]</sub> as well as Rawdraw Android<sub>[#W30]</sub>, the minimum requirements for dealing with an Android application are a handle for the provided application and an `android_main` which the NDK will call. From there you can reroute to your own application and do there what you need.

~~~~~~~~~~~~~~~~~~~~~~~~~~c++ linenumbers
#include <android_native_app_glue.h>
#include <android/native_activity.h>
#include <android/log.h>
#include <stdio.h>

struct android_app* my_app;

int main(int argc, char** argv)
{
    __android_log_print(3, "CMakeExample_Android", "Hey from main!");
    return 0;
}

void android_main(struct android_app* app)
{
    __android_log_print(3, "CMakeExample_Android", "CMakeExample Init");
    my_app = app;
    
    __android_log_print(3, "CMakeExample_Android", "CMakeExample Calling Main");
    char *argv[] = {"CMakeExample_Android", 0};
    main(2, argv);

    __android_log_print(3, "CMakeExample_Android", "CMakeExample Closing...");
    ANativeActivity_finish(my_app->activity);
    exit(0);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~

Besides the required steps for an Android application, the main contents remain the same. Instead of using `printf` we use `__android_log_print` and the actual main is `android_main` which will call our actual `main` function.

At the end, we make the necessary calls to finish the application from the Native Activity and then a forced exit, because there is no clean way of exiting an application from inside.

## Debugging

Although I am a pretty heavy  on log based debugging, I believe it's not the best solution but only the simplest available. After all, cryptic crash messages as well as fishing for errors with carefully placed logs, become a mess and almost close to divination when debugging unknown elements. For that reason a fast entry to available debugging capabilities is needed.

On Windows the decision was obvious as CMake can directly generate the required project files for a Visual Studio solution, then it is just needed to keep developing as usual. The issue is with the newly adopted platforms: Linux and Android.

### Linux: GDB and KDevelop

The first search for debuggers in Linux brought me to GDB, a command line yet visual debugger utility. With the only requirements being a debug compiled C/C++ application, not printing to console ever from code (avoid anything that prints to executing console, like _printf_) and getting used to a couple commands, seemed a good fit for getting started fast with a new platform. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bash
gdb "path/to/executable"
layout next # Open the file debugger view
run # start execution
b / breakpoint <number> # setup a breakpoint at line
d / delete # delete all breakpoints
c / continue # continue execution
n / next # execute next line
s / step # step into functions
u / until # continue execution until a loop is exited if you are in a loop
p / print <variable_name> # print the value contained in a variable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As can be seen in **Figure 16**, the experience is pretty barebones but much better than having to debug by just getting default crash messages, GDB will point out where and when these crashes ocurr.

![Figure [figures]: Example GDB view of main file while executing a sample application from SqueLib.](images/gdb_example_pong.png width=80%)

At the same time, getting into a command line debugging tool is still quite a jump from Visual Studio. Luckily the chosen Linux distro, KUbuntu, comes with an extensive marketplace and applications which include a lightweight C/C++ IDE with direct support for CMake based projects, lowering the entry requirement to Linux development.

The process of importing and debugging a CMake based project just requires the user to know the desired initial commands from which one needs to call CMake with and to create an executable profile for the application, process which is explained under the *KDevelop Documentation Manual*<sub>[#W31]</sub> under the *Sessions and Projects/Seteting up a Session and Importing an existing project/Option 2*. The main development environment in KDevelop is shown under **Figure 17**:

![Figure [figures]: Sample application being debugged from KDevelop.](images/kdevelop_example_pong.png width=90%)

### Android: APK Profiler

The simplest way to get the Android SDK and NDK is by performing the installation alongside Android Studio, which is pretty handy in the way that you do not require a fully fledged Android Studio project to debug it. Android Studio has a built in profiler/debugger for APKs that have been built with the debug symbols, only requiring access to the original debugging files which are either inside the apk itself and can be extracted from, or are already available on the system after building the project through external means.

<span class="pagebreak"></span>

Android Studio also provides emulators and virtual devices, although they are tied to the host computer architecture. That is a big issue for me and developers without an ARM computer as the last developed x86 based Android device was released in March 2015<sub>[#W32]</sub> and the Intel Atom line was discontinued around 2016<sub>[#W33]</sub>. The same path is going for 32bit based ARM systems, on of the reasons why the final build process will only target 64bit ARM systems (less build time and less worries).

The solution is passthrough debugging. As long as you have a physical device in which you can install your built application and a USB cable (or WIFI on Android 11 or higher), it is possible to link the process execution from the device to Android Studio and debug in realtime.

<!-- Image of my phone and Android Debugging at the same time... -->

# SqueLib Development

<!-- Explanation of waht should the core workflow should be and what are the expected capailities -->

When working with SqueLib, it is intended for the library to take control of the initialization process of the application, referring to the main window, render and input. At the same time facilities for interfacing with said module are to be provided in a simple and easy to implement manner. Under **Figure 18** the expected architecture of the library is shown:

***************************************************************************
* .----------------------------------------------------------------------.*
* | .----------------------.  .----------------------------------------. |*
* | | .-------.   .------. |  | .-------. .-------------. .----------. | |*
* | | |Display|   |Render| |  | |Logging| |Asset Loading| |Structures| | |*
* | | '-------'   '------' |  | '-------' '-------------' '----------' | |*
* | |                      |  |                                        | |*
* | | .----------. .-----. |  | .-------------. .-----. .------------. | |*
* | | |Filesystem| |Input| |  | |Serialization| |Timer| | Algorithms | | |*
* | | '----------' '-----' |  | '-------------' '-----' '------------' | |*
* | |         . . .        |  |                  . . .                 | |*
* | '----------------------'  '----------------------------------------' |*
* |            Core                             Utilities                |*
* '----------------------------------------------------------------------'*
***************************************************************************
[Figure [diagram]: Expected material provided by SqueLib.]

Some modules' requirements can change as they are developed, there may be required extra modules or integration of other libraries for other tasks. For this reason it is expected for features or needs to grow the project requirements.

Before delving into each part of the library provided, code will be provided in the document for elements that are specifically relevant to the subject at question such as multiplatform approaches or specific things for Android and Linux, given that during the coursing of the degree the apporach has focused on Windows.

## SqueLib C++ Coding Conventions

~~~~~~~~~~~~~~~~~~~~c++
// INTRODUCTORS_ARE_CAPS_SEPARATED_BY_UNDERSCORES
// they are used to define which part they refer to and avoid collisions

#define MACROS_ARE_UPPERCASE 0

void FunctionsAreCamelCase()
{
    // And Brackets go in the line below
}

void variables_are_lowercase_separated_by_underscore;

typedef variable_is_underscore int;

typedef void(CallbackAreCamelCase)();
// Also Callbacks should not hide a pointer
// You can declare a CallbackType as a functor -> Callback*

#ifdef CHAINS
#   if CAN_HAVE_#_AT_SAME_LEVEL
#   endif // Then indent the text
#elseif OR

#define CAN_BE_SEPARATED_BY_LINE_BREAK

#endif // Both are clarificatory enough

struct ID1_IsCamelCase
{
    void cant_contain;
    bool explicit_constructor;
    int explicit_destructor;

    Class1 but_can_contain_classes_as_variables;
};

class ID2_IsCamelCaseToo
{
public: // Recommend Public Constructors/Destructors first
    ID2_IsCamelCaseToo(){};
    ~ID2_IsCamelCaseToo(){};

public: // Public Variables
    void public_var;
public: // Public Functions
    void PublicFunctions(){};
private: // Private Variables
    void* private_var;
private: // Private Functions
    void PrivateFunction(){};
};

enum ID3_AreCamelCaseToo
{
    ENUM_VAL1_IS_UPPERCASE = 0, // Value 1 has to be defined always
};

void ModifyingFunctionsPassAsPointer(int* modifiable){}
void NonModifying_ConstClasses_AsReferences(const class_type_t& classes_structs){};
void NonModifying_ConstFundamentalTypes_AsCopy(const int fundamental_types){}
// These might vary for Callbacks that send to or receive from other libraries

/*
    Indentation is a controversial topic that actually should never have to be discussed by coders.
    There should be a consesus for a serialization value that indicate an indentation,
    that should be serialized with the file and each IDE provide a setting for such spacing.
*/
~~~~~~~~~~~~~~~~~~~~

## Core Library

The core implementation of the library should allow a low C++ experience level user create an application with a window, control the display inside the window, have access to the main inputs performed and finally, be able to load and write raw binary files.

These will be the main points that the library should accomplish, as well as being able to perform these actions seamlessly across the target platforms. This process of making the required functionality work properly for the platforms as well as have them easy for the user to access, causes limitations to arise and circumvent.

### Library Base

Implementation details from external libraries should remain private towards the user, meaning that the user will not be able to call directly GLFW, EGL or OpenGL, they will have to go through the library in order to interact with the systems.

#### Exporting Symbols

A requirement in Windows is to set the visibility or how functions are exported and imported depending on the context of the library build. Maybe a user will import it and use it directly in their project, anohter will have it as a static library and a third one as a dynamic library.

In all cases, there are some requirements on how to export the symbols<sub>[#W55]</sub>, which are not necessarily needed on other platforms but it would be good practice to do so:

~~~~~~~~~~~~~~~~~~~~~~c++
#ifndef SQ_API		
#   ifdef _WIN32
#       if defined(SQ_BUILD_SHARED) /* build dll */
#           define SQ_API __declspec(dllexport)
#       elif !defined(SQ_BUILD_STATIC) /* use dll */
#           define SQ_API __declspec(dllimport)
#       else /* static library */	
#           define SQ_API				
#       endif					
#   else /* Linux, Android,...*/
#       define SQ_API
#   endif					
#endif
// Visibility implementation on GCC would be SQ_API __attribute((visibility("default"))
// Might change for other compilers and versions
~~~~~~~~~~~~~~~~~~~~~~

#### Android Initialization

As seen previously with the **Android Minimal Example**, there needs to be a rerouting to enter user main. In order to take care of Android Initialization, the library provides already the `android_main` in which a standard user provided `main(int argc, char** argv)` will be called in order to start execution of user code.

In this same `android_main` the basic steps for initializing other subsystems for Android should be taken care of. A specific case is the `HandleAndroidInput` which will be defined under the Input source file, we set it up as an extern to setup the callback:

~~~~~~~~~~~~~~~~~c++
#ifdef ANDROID

#include <android_native_app_glue.h>
#include <android/log.h>

void HandleAndroidCMD(struct android_app* app, int32_t cmd)
{
    switch (cmd)
    {
        // Take care of Android Commands
    }
}

// Used in the Input Module
extern int HandleAndroidInput(struct android_app* app, AInpuitEvent* ev);

extern int main(int argc, char** argv);

struct android_app* my_app;

void android_main(struct android_app* app)
{
    LOG(LOGTYPE, "SQUE_LIB - Android Squelib Start...");
    my_app = app;
    app->onAppCmd = HandleAndroidCMD;
    app->onInputEvent = HandleAndroidInput;

    LOG(LOGTYPE, "SQUE_LIB - Calling App Main...");
    char *argv[] = {"AppMain", 0};
    main(2, argv);

    LOG(LOGTYPE, "SQUE_LIB - Finished executing App...");
}

#endif // ANDROID
~~~~~~~~~~~~~~~~~

#### Printing to Console

An abstraction that will allow the users to print to console regardless of the environment they are at, using a simple approach with a variadic list and a macro.

The macro uses the `__FILE__` and `__LINE__` macros to pass to `SQUE_PrintVargs` where the call originates and accepts a string for formating as well as the variadic list of values. Said function will extract the filename, add the string with the specified format and then print it to console using the abstraction.

For using priority levels, a simple logtype enum that matches Android's log values<sub>[#54]</sub> is setup.

~~~~~~~~~~~~~~~~~c++
enum SQUE_LogType
{
	LT_INFO = 4,
	LT_WARNING,
	LT_ERROR,
	LT_CRITICAL
};

void SQUE_PrintVargs(SQUE_LogType lt, const char file[], int line, const char* format, ...)
{
    const char* sttr = strrchr(file, FOLDER_ENDING);
    uint32_t sttr_len = strlen(sttr);

    static va_list ap;
    char* tmp = new char[1];
    va_start(ap, format);
    int len = vsnprintf(tmp, 1, format, ap) + 1;
    va_end(ap);
    delete[] tmp;

    tmp = new char[len];
    va_start(ap, format);
    vsnprintf(tmp, len, format, ap);
    va_end(ap);

    int print_len = len + (sttr_len + 4 + 4);
    char* print = new char[print_len];
    sprintf(print, "%s(%d): %s", sttr, line, tmp);

    SQUE_ConsolePrint((int)lt, print);

    delete[] tmp;
    delete[] print;
}

void SQUE_ConsolePrint(int lt, const char* log)
{
#if defined(_WIN32) //&& defined(_DEBUG)
    OutputDebugString(log);
    OutputDebugString("\n");
#elif defined ANDROID
    __android_log_print(lt, "SqueLib", log);
#elif defined LINUX
    printf("LOGTYPE %d: %s\n", lt, log);
#endif

}

#define SQUE_PRINT(LogType, format, ...) SQUE_PrintVargs(LogType, __FILE__, __LINE__, format, ##__VA_ARGS__)
~~~~~~~~~~~~~~~~~

#### Macro Remapping

Given that the library will work over multiple other libraries, as well as have its own types, macros and functions, it is important to define a way to circumvent the usage of library specific things without alienating it too much so that it becomes not recognizable.

GLFW, OpenGL and EGL are heavy users of enum and macros for configuration and runtime things and the user should not have to know which one to specifically use on a per backend basis.

Althought the solution is not pretty for the one that has to deal with the implementation, it translates into a seamless experience for the user when using the required types.

~~~~~~~~~~~~~~~~~~~~c++
// Example: There are macros that don't map, so an invalid value is set that should throw silent errors
#if defined(GLFW)
    #define SQUE_INVALID GFLW_MACRO_INVALID_VALUE
    #define SQUE_MACRO_1 GLFW_MACRO_X
    #define SQUE_MACRO_2 GLFW_MACRO_X2
#elif defined(EGL)
    #define SQUE_INVALID EGL_MACRO_INVALID_VALUE
    #define SQUE_MACRO_1 EGL_MACRO_Y
    #define SQUE_MACRO_2 SQUE_INVALID
#endif
~~~~~~~~~~~~~~~~~~~~

#### Library-wide Init and Close

In order to make the library more usable, a single init and close point will be provided for those who prefer it. The details change depending on the implementation of each module but the template implementation of such a function should do something like this:

~~~~~~~~~~~~~~~~~~~c++ linenumbers
SQUE_LIB_INIT(const char* app_name, int32_t flags)
{
    //...
    if(CHK_FLAG(flags, DEFAULT_FLAGS))
    {
        // Inits in default config
    }
    else if(CHK_FLAG(flags, CUSTOM_FLAGS))
    {
        // Init modules in a specific way
    }
    //...
}

SQUE_LIB_Close()
{
    //...
    SQUE_RENDER_Close();
    SQUE_INPUT_Close();
    SQUE_DISPLAY_Close();
    SQUE_FS_Close();
#ifdef ANDROID
    ANativeActivity_finish(my_app->activity);
#endif
    //...
}
~~~~~~~~~~~~~~~~~~~

### Window Control

The management of a window is basically the same as an application loop, given a configuration a window will be initialized in which you will update what is displayed until it is time to close the whole application, shown in **Figure 19**. What differs from a simple desktop application is that this process has to be adapted and limited to work seamlessly with a base Android device as well as the chosen libraries.

************************************************************************************************
*.------------.   .------------.   .----------------.     CloseApp  .---------------.
*| Set Config +-->| Initialize +-->| Update Display +----*--------->| Close Display |
*'------------'   '------------'   '----------------'    |          '---------------'
*                                           ^            |
*                                           | Next Frame |
*                                           '------------'
************************************************************************************************
[Figure [diagram]: Usual display management loop.]

Both GLFW and EGL take care of generating the context in which the rendering API will work on, in this case OpenGL. The initialization step will have to take care of launching a main window to which the rendering context is tied, then if it is necessary, other displays would be opened separately but only on desktop devices. Currently there is no support for multiple windows in a single application from the Android NDK, instead it is required to initialize a new activity for it. Given the complexity, multiple windows will not be supported.

#### Configuration and Initialization

Configuring both APIs is straightforward, a couple of functions for setting the next window hints are provided which will be used for the creation of the main window the application runs in. These hints are stored and later setup when performing either the initialization or, should it be supported, when opening another window.

The `Hints` are passed down as an array of integer values, as both GLFW and EGL work through their own enum values that have been remapped by SqueLib to make it seamless. Both libraries ignore invalid hints and continue with their respective initialization steps.

~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
SQ_API void SQUE_DISPLAY_NextWindow_WindowHints(int32_t* options, int32_t size);
SQ_API void SQUE_DISPLAY_NextWindow_ContextHints(int32_t* options, int32_t size);
SQ_API void SQUE_DISPLAY_NextWindow_BufferHints(int32_t* options, int32_t size);
SQ_API void SQUE_DISPLAY_NextWindow_Title(const char* title);
SQ_API void SQUE_DISPLAY_NextWindow_Size(const uint32_t width, const uint32_t height);
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Then initialization steps comes and performs the initialization depending on the backend. The actual code changes a bit but the following pseudo-c++ code should show the requirements for getting it to work on both platforms:

~~~~~~~~~~~~~~~~~~~~~~~~~~~c++ linenumbers
#ifdef EGL
    extern struct android_app* my_app;
    extern int graphics_backend_started;
    EGLNativeWindowType egl_window;
    EGLDisplay egl_display;
    EGLSurface egl_surface = EGL_NO_SURFACE;
    EGLContext egl_context;
#elif defined(GLFW)
    GLFWmonitor** glfw_monitors;
    int monitor_count;
    GLFWwindow** glfw_windows;
#endif

void SQUE_DISPLAY_Init()
{

#ifdef EGL
    EGLint egl_major, egl_minor;
    int events;
    // Android will crash if you don't wait for the backends to be initialized asynchronously
    while(!graphics_backend_started)
    {
		struct android_poll_source* source;
		if (ALooper_pollAll( 0, 0, &events, (void**)&source) >= 0)
		{
			if (source != NULL) source->process(my_app, source);
		}
	}
    // Initialize for the main display
    egl_display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
    eglInitialize(egl_display, &egl_major, &egl_minor);
    EGLConfig config;
    EGLint num_config;
    // Return a single base full configuration that works with the display
    eglChooseConfig(egl_display, buffer_hints, &config, 1, &num_config);
    // Create a rendering context given a series of hints and the full config
    egl_context = eglCreateContext(egl_display, config, EGL_NO_CONTEXT, context_hints);
    // Set the egl_window to the Android NativeWindow
    egl_window = my_app->window;
    base_window->width = ANativeWindow_getWidth(egl_window);
    base_window->height = ANativeWindow_getHeight(egl_window);
    // Create a surface to draw on from the obtained window and a series of hints
    egl_surface = eglCreateWindowSurface(egl_display, config, egl_window, window_hints);

#elif defined(GLFW)
    int glfw_major, glfw_minor, glfw_revision;
    glfwGetVersion(&glfw_major, &glfw_minor, &glfw_revision);
    // Pass init hints glfwInitHint()...
    glfwInit();
    glfw_monitors = glfwGetMonitors(&monitor_count);
    glfwGetMonitorWorkArea(glfw_monitors[0], base_window->x, base_window->y, base_window->width, base_window->height);

    // GLFW has a same function for all the hints, but EGL separates them in the Window/Buffer/Context types
    // as it initializes separately the surface, context and window
    for(uint16_t i = 0; i < window_hints.size(); i+=2)
        glfwWindowHint(window_hints[i], window_hints[i+1]);
    for(uint16_t i = 0; i < buffer_hints.size(); i+=2)
        glfwWindowHint(buffer_hints[i], buffer_hints[i+1]);
    for(uint16_t i = 0; i < context_hints.size(); i+=2)
        glfwWindowHint(context_hints[i], context_hints[i+1]);

    // Perform the initialization of a full window, with its rendering context
    glfw_windows[0] = glfCreateWindow(base_window->width, base_window->height, "Title", 0, NULL);
    // Set window callbacks...
#endif
    // Set the context of the generated window to be the main
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~

#### Updating Display

The main functions to take care of the main display are really swapping back with front buffer to show the next drawn frame and making such buffer the one to write to. When interfacing with OpenGL, the user might be writting to different buffers which they will bind and unbind as they seem fit. 

In case that the user does not want to worry about handling the buffer swap state, this pair of functions can be called successively to perform that buffer swap properly:

~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
void SQUE_DISPLAY_MakeContextMain(uint16_t window)
{
    SQ_ASSERT(window < sque_windows.size())
#if EGL
    if (!eglMakeCurrent(egl_display, egl_surface, egl_surface, egl_context))
    {
        SQUE_PRINT(SQUE_LogType::LT_ERROR, "Failed to attach Context to Surface (eglMakeCurrent())!");
        exit(0);
    };
#elif define(GLFW)
    glfwMakeContextCurrent(glfw_windows[window]);
#endif
}

void SQUE_DISPLAY_SwapBuffer(uint16_t window)
{
    SQ_ASSERT(window < sque_windows.size())
#if EGL
    eglSwapBuffers(egl_display, egl_surface);
#elif defined(GLFW)
    glfwSwapBuffers(glfw_windows[window]);
#endif
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~

As seen above, the functions receive a handle to the window, rather than the window itself. During the process of developing the library, the plan was to support multiple windows but the complexity of managing them was too much. Still a variable to pass which window to interact on is passed which makes sense in the long-run.

Other functions that take care of managing the state of a window as well as callbacks are provided to get the user to manage it their own way, although the library will have a default functions set.

~~~~~~~~~~~~~~~~~~~~~~~~c++
// Setters
void SQUE_DISPLAY_SetVSYNC(const int16_t vsync_val);
void SQUE_DISPLAY_SetWindowClose(const uint16_t window = 0);
uint16_t SQUE_DISPLAY_CloseWindow(const uint16_t window = 0);
void SQUE_DISPLAY_ResizeWindow(const uint16_t w, const uint16_t h,const uint16_t window = 0);
void SQUE_DISPLAY_SetWindowIcon(const int32_t width, const int32_t height, void* pixels, const uint16_t window = 0);
void SQUE_DISPLAY_SetMouseMode(const int32_t value, const uint16_t window = 0);

// Getters
bool SQUE_DISPLAY_ShouldWindowClose(const uint16_t window = 0);
uint16_t SQUE_DISPLAY_GetAmountWindows();
void SQUE_DISPLAY_GetWindowPos(int32_t* x, int32_t* y, const uint16_t window = 0);
void SQUE_DISPLAY_GetWindowSize(int32_t* w, int32_t* h, const uint16_t window = 0);
void SQUE_DISPLAY_GetViewportSize(int32_t* w, int32_t* h, const uint16_t window = 0);
void* SQUE_DISPLAY_GetPlatformWindowHandle(const uint16_t window = 0);
int32_t SQUE_DISPLAY_GetDPIDensity(const uint16_t window = 0);
void SQUE_DISPLAY_GetMainDisplaySize(uint16_t* w, uint16_t* h);

// Callbacks
typedef void(ResizeCallback)(int32_t width, int height);
typedef void(ViewportGetSizeCallback)(int32_t* width, int32_t* height);
typedef void(HandleDropFileFun)(const char* location);
ResizeCallback* SQUE_DISPLAY_SetViewportResizeCallback(ResizeCallback* viewport_cb);
ViewportGetSizeCallback* SQUE_DISPLAY_SetViewportGetSizeCallback(ViewportGetSizeCallback* viewport_size_cb);
HandleDropFileFun* SQUE_DISPLAY_SetDropFileCallback(HandleDropFileFun* drop_file_cb);

~~~~~~~~~~~~~~~~~~~~~~~~

Following GLFW's structure for callbacks, each callback setter function will return as well teh previously set callback in order for the user to prevent breaking other implementations that might have already setup a callback to such action.

#### Closing Display

Part of the previous update function set, were two setters for a window to close and a checker for a window to close.  `SQUE_DISPLAY_SetWindowClose` sets the intent to close the window, for `SQUE_DISPLAY_ShouldWindowClose` to poll, `SQUE_DSIPLAY_CloseWindow` actually closes the window.

Using these one should be able to decide where they want to decide to perform such actions. To actually cleanup the module teh function `void SQUE_DISPLAY_Close()` is provided, which actually performs the cleanup for GFLW and the proprietary window handles.
EGL does not have such a closure, it is dealt by the Android NDK the moment the whole application shut downs or is thrown into background.

### Input Management

The process of taking care of inputs strays a bit from the latter module. In **Figure XX** can be appreaciated that most abstractions to input systems work in two differents ways at the same time, all of the rooting in a poll function:

***********************************************************************************************************
* .------------.
* | Init Input |
* '------+-----'                         App Continue Running
*        |               .-------------------------------------------------.
*        v               |                                                 |       .-------------.
* .------+-------------. v  .--------------------.   .-----------------.   | App   | Close Input |
* | Register Receivers +-+->| Poll System Inputs +-->| App Update Loop +---*------>|   System    |
* '--------------------'    '----------+---------'   '------+-----+----'     Close '-------------'
*                                      |                    ^     ^
*                                      v                    |     |
*                               .-------------.   <Polling> |     |
*                               | Save States |<------------'     |
*                               '------+------'                   |
*                                      |                          |
*                                      v                          |
*                            .------------------.                 |
*                            | Send Callback to |   >interrupts>  |
*                            |   the receivers  |-----------------'
*                            '------------------'
***********************************************************************************************************
[Figure [diagram]: Input Module Loop]

Usually the user will register some receivers, which will as appropiately named receive the inputs that are polled by the input system. Another step is that the user might want to specifically poll for an input state to which it has not designated a receiver, setting up a second polling operation or a spontaneus check.

The Android NDK does not really have a good support for the first kind, making the user setup its own loop for taking care of such things. GLFW on the other hands provides receivers for mostly every input imaginable for a Desktop platform, be it keyboard, mouse or joysticks.

#### Initialization

For the Android NDK, the input was setup previously at the initialization step for the library, by setting the callback `HandleAndroidInput` to the `android_app`. For GLFW there is not much more complications but GLFW ties input to each separate window, as such the initialization step for the library input will target he main window created. Here setup the first order dependency for initialization **Display -> Input -> ...**.

~~~~~~~~~~~~~~~~~~~~~~~~~c++
void SQUE_INPUT_Init()
{
    SQUE_INPUT_InitForWindow(0);
}

#if defined GLFW
extern GLFWwindow** glfw_windows;
#endif

void SQUE_INPUT_InitForWindow(uint16_t window)
{
#if USE_GLFW
    assert(window > glfw_windows.size());

    glfwSetInputMode(glfw_windows[window], GLFW_RAW_MOUSE_MOTION, GLFW_TRUE);
    glfwSetKeyCallback(glfw_windows[window], GLFW_KeyCallback);
    
    glfwSetCursorPosCallback(glfw_windows[window], GLFW_MousePosCallback);
    glfwSetMouseButtonCallback(glfw_windows[window], GLFW_MouseButtonCallback);
    glfwSetScrollCallback(glfw_windows[window], GLFW_MouseScrollCallback);
    glfwSetCharCallback(glfw_windows[window], GLFW_CharCallback);
#endif
}
~~~~~~~~~~~~~~~~~~~~~~~~~

SqueLib provides the base GLFW callbacks that update the key state internally and then call the setup callback by the user on each key options.

#### Callback System

In order to make the translation as seamless as possible between touch based and keyboard-mouse platforms, setting up a basic callback system seemed fit as it is very comfortable to use and quite an integral part of GLFW.

~~~~~~~~~~~~~~~~~~~~~~~~~c++
typedef void(KeyCallback)(int32_t code, int32_t state);

enum SQUE_INPUT_Actions							
{
	SQUE_ACTION_UNKNOWN = -1,			
	// Button States		
	SQUE_ACTION_RELEASE,				
	SQUE_ACTION_PRESS,		
	SQUE_ACTION_REPEAT,		
	// Single Touch Controls			
	SQUE_ACTION_TAP,						
	SQUE_ACTION_SWIPE_UP,	
	SQUE_ACTION_SWIPE_DOWN,	
	SQUE_ACTION_SWIPE_LEFT,	
	SQUE_ACTION_SWIPE_RIGHT,	
	
    // 
	SQUE_ACTION_MAX						
};

struct SQUE_Key
{		
	int prev_state = -1;			
	int state = -1;					
	KeyCallback* callback;																		
};	
~~~~~~~~~~~~~~~~~~~~~~~~~

In conjunction, every basic touch action as well as keyboard, mouse and joystick pressed can be summed in the following key states. A key holds previous state and the current polled state, as well as having a direct callback to setup should it be necessary for the user to have an interrupt on a key action with the identifier as well as the state.

After the states, a couple default touch actions are set in the same enum to take care of the basic single touch gestures. Touch and Gestures will be explained in the **Touch Input and Gestures** chapter. 

##### Registering Receivers

The process is pretty straightforwards, call the required functions and such action will be setup to the passed function. A specific takeaway, also present and mentioned in the **Display** chapter, these function return the previously setup character making it possible to chain these callbacks and not break previous implementations if the user is unsure.

~~~~~~~~~~~~~~~~~~~~~~~~c++
typedef void(MouseFloatCallback)(float x, float y);

KeyCallback* SQUE_INPUT_SetKeyCallback(KeyCallback* sque_key_fn);			
MouseFloatCallback* SQUE_INPUT_SetPointerPosCallback(MouseFloatCallback* position, uint16_t pointer);
MouseFloatCallback* SQUE_INPUT_SetScrollCallback(MouseFloatCallback* scroll);
KeyCallback* SQUE_INPUT_SetMouseButtonCallback(const int button, KeyCallback* key_callback);		
~~~~~~~~~~~~~~~~~~~~~~~~

#### Polling Inputs

During the GLFW initialization we did already setup how our library will provide the inputs, what is left for GLFW is to call `glfwPollEvents()` somewhere and all inputs generated since the last poll will be setup. On the Android NDK we process all events in the app event queue, which will call the previously setup `HandleAndroidInput` callback on each found event.

~~~~~~~~~~~~~~~~~~~~~~~~~c++
void SQUE_INPUT_Process(uint16_t window)
{
#ifdef ANDROID
    int events;
    struct android_poll_source* source;
    while (ALooper_pollAll(0, 0, &events, (void**)&source) >= 0)
    {
        if (source != NULL)
        {
            source->process(my_app, source);
        }
    }
#elif defined USE_GLFW
    glfwPollEvents();
#endif
}
~~~~~~~~~~~~~~~~~~~~~~~~~

And the definition of what `HandleAndroidInput` does:

~~~~~~~~~~~~~~~~~~~~~~~~~c++
int32_t HandleAndroidInput(struct android_app* app, AInputEvent* ev)
{
    int32_t evtype = AInputEvent_getType(ev);
    int32_t ret = 1;
    switch(evtype)
    {
        case AINPUT_EVENT_TYPE_KEY:
            ret = HandleAndroidKey(app, ev);
            break;
        case AINPUT_EVENT_TYPE_MOTION:
            ret = HandleAndroidMotion(app, ev);
            break;
    }
    return 1;
}
~~~~~~~~~~~~~~~~~~~~~~~~~

This function redirects to different types of events. In short, `AINPUT_EVENT_TYPE_KEYS` are the software keyboard keys and will update the same as what GLFW would update althought the keys will not match one to one, but function just well for an external keyboard to be used as input in an Android application.

The point of interest is in `HandleAndroidMotion` which will be explained later on. For now, the polling loop is already setup and working as close as possible to GLFW.

Finally, for the user to poll the inputs, there are the following functions provided:

~~~~~~~~~~~~~~~~~~~~~~~~~c++
SQUE_INPUT_Actions SQUE_INPUT_GetKey(const uint16_t window, const SQUE_KeyboardKeys key);
SQUE_INPUT_Actions SQUE_INPUT_GetMouseButton(const uint32_t button);
void SQUE_INPUT_GetPointerAvgPos(float* x, float* y, const uint16_t points = 1);
bool SQUE_INPUT_GetPointerPos(float* x, float* y, const uint16_t pointer = 0);
void SQUE_INPUT_GetScroll(float* v = NULL, float* h = NULL);
~~~~~~~~~~~~~~~~~~~~~~~~~

#### Keyboard and Mouse

The process of getting the inputs for both keyboard and mouse is setup through the provided callbacks for GLFW and `HandleAndroidKey` for keyboard on the Android NKD:

~~~~~~~~~~~~~~~~~~~~~~~~~c++
#if defined GLFW
static void GLFW_KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    keyboard[key].prev_state = keyboard[key].state;
    keyboard[key].state = action;
    keyboard[key].callback(key, keyboard[key].state);
    key_fun(key, keyboard[key].state);
}

static void GLFW_MousePosCallback(GLFWwindow* window, double xpos, double ypos)
{
    pointers[0].x = (float)xpos;
    pointers[0].y = (float)ypos;
    pointers[0].pos_callback(pointers[0].x, pointers[0].y);
}
static void GLFW_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods)
{
    mouse_buttons[button].prev_state = mouse_buttons[button].state;
    mouse_buttons[button].state = action;
    mouse_buttons[button].callback(button, mouse_buttons[button].state);
    pointers[0].active = mouse_buttons[button].state > SQUE_ACTION_RELEASE;
}

static void GLFW_MouseScrollCallback(GLFWwindow* window, double xoffset, double yoffset)
{
    scrollx = xoffset;
    scrolly = yoffset;
    scroll_callback(scrollx, scrolly);
}

#elif defined ANDROID

int32_t HandleAndroidKey(struct android_app* app, AInputEvent* ev)
{
    int code = AKeyEvent_getKeyCode(ev);

    int unicode = AndroidGetUnicodeChar(code, AMotionEvent_getMetaState(ev));
    if (AKeyEvent_getAction(ev) == 1) char_buffer.push_back(unicode);

    if (unicode && unicode < MAX_KEYS)
    {
        keyboard[code].prev_state = keyboard[code].state;
        keyboard[code].state = AKeyEvent_getAction(ev);
        keyboard[code].callback(unicode, keyboard[code].state);
        key_fun(code, keyboard[code].state);
    }

    return 1;
}

#endif
~~~~~~~~~~~~~~~~~~~~~~~~~

For the Android NDK implementation, mouse input is setup with a passthrough from the first touch input available.

#### Touch Input and Gestures

The Android NDK provides touch inputs through touch motions, meaning that it actually resembles more a multi mouse setup which are called pointers. The process is very similar to polling the state of a key, iterate through the available ones and retrieve the state but at the same time obtain the position they are at that point. It is important to remark that a pointer will remain static until it is active again.

The following is the barebones implementation of the `HandleAndroidMotion` function:

~~~~~~~~~~~~~~~~~~~~~~~~~c++ linenumbers
#ifdef ANDROID
int32_t HandleAndroidMotion(struct android_app* app, AInputEvent* ev)
{
    int32_t action = AMotionEvent_getAction(ev);
    if (action == AMOTION_EVENT_ACTION_CANCEL)
        return -1;

    int num_pointers = AMotionEvent_getPointerCount(ev);
    if (num_pointers >= MAX_POINTERS) return -1; // Ignore pointer you don't support

    // Retrieve source ID for the pointer
    int whichsource = action >> 8;
    // Actions are provided in non matching values to the intended enums
    APPLY_MASK(action, AMOTION_EVENT_ACTION_MASK);
    bool motion_ended = true;
    // Mouse Passthrough -> Pointer[0] will become the mouse
    if(num_pointers > 0)
    {   
        if(/*whichsource matches pointer[0] id*/)
            switch (action)
            {
                // Update MouseButton[0] state based on the action
                // Position will be updated with the rest of the pointers
            }
    }
    for (int i = 0; i < num_pointers; ++i)
    {
        SQUE_PRINT(LT_INFO, "Get Pointer %d Status...", i);
        int x, y;
        int pointer = GetPointer(AMotionEvent_getPointerId(ev, i));
        x = AMotionEvent_getX(ev, i);
        y = AMotionEvent_getY(ev, i);
        
        // Get Pointer that corresponds to whichsource == id
        Pointer p;
        switch (action)
        {
            // Setup the pointer state and position according to the action
            // Here are the equivalences to keys
            // AMOTION_EVENT_ACTION_DOWN == Press
            // AMOTION_EVENT_ACTION_MOVE == Repeat
            // AMOTION_EVENT_ACTION_UP == Release
        }
        if(motion_ended == true) motion_ended = !p.active;
    }
    
    if(motion_ended) 
    {
        SQUE_PRINT(LT_INFO, "Evaluate Motion event...");
        for(uint16_t i = 0; i < pointer_num; ++i)
            SQUE_INPUT_DetectGesture(gestures[i]);
    }

    return 1;
}
#endif
~~~~~~~~~~~~~~~~~~~~~~~~~

In the function there are some referencies to check if a motion has ended. A motion is active depending on the sum of activities of the pointers. If non are active, motion will be inactive and a gesture will be evaluated on a per pointer basis.

Each gestures is simply the tracking of a pointer from start position to end position, given a time frame. The current implementation only detects a `TAP` and a `SWIPE` motion:

~~~~~~~~~~~~~~~~~~~~~~~~~c++

struct SQUE_Gesture							
{						
	SQUE_Timer timer;

	float start_x, start_y;
	float midpoints[MAX_MIDPOINTS][2];		
	float end_x, end_y;

	float refresh_bucket;							
};	

SQUE_INPUT_Actions SQUE_INPUT_DetectGesture(const SQUE_Gesture& g)
{
    // Evaluate what the pointer has done during the time it was tracked
    int16_t delta_x = g.end_x - g.start_x;
    int16_t delta_y = g.end_y - g.start_y;
    int32_t screen_w, screen_h;
    SQUE_DISPLAY_GetWindowSize(&screen_w, &screen_h);

    uint16_t abs_delta_x = delta_x;
    uint16_t abs_delta_y = delta_y;
    float dist_perc_x = 100 * abs_delta_x / (float)screen_w;
    float dist_perc_y = 100 * abs_delta_y / (float)screen_h;

    uint16_t time = g.timer.ReadMilliSec();
    // Tap Gesture
    if (time <= GESTURE_REFRESH || (abs_delta_x < 5 && abs_delta_y < 5))
    {
        return SQUE_INPUT_Actions::SQUE_ACTION_TAP;
    }
    // Swipe Gesture
    else if (time > GESTURE_REFRESH && time <= 3 * GESTURE_REFRESH)
    {
        if (abs_delta_x > abs_delta_y)
            return (SQUE_INPUT_Actions)(SQUE_ACTION_SWIPE_LEFT + (int)(delta_x > 0)); // Swipe Horizontal
        else
            return (SQUE_INPUT_Actions)(SQUE_ACTION_SWIPE_UP + (int)(delta_y < 0));  // Swipe Vertical
    }

    return SQUE_INPUT_Actions::SQUE_ACTION_UNKNOWN;
}
~~~~~~~~~~~~~~~~~~~~~~~~~

### Render Pipeline

The approach for rendering graphics in both OpenGL 3.3 and OpenGLES 3.2 are parctically the same, even the GLSL supported version mirror almost one to one. The implementation towards the user becomes very easy, just write passthrough functions on the parts that are being supported.

In order to get a base case for working with a basic render pipeline, I decided to go through **LearnOpenGL[#W56]** and have the library perform effortlessly such part. The intent of the library is to ease the user into declaring and knowing the data they are working with first and then during realtime operations just have to worry about know which handles to use, seen below in **Figure 20**.

*************************************************************
* .-------------.    .----------------.    Close .--------.
* | Init Handle +--->| Send To Render |--*------>| Delete |
* '-+-----------'    '----------------'  |       '--------'
*   +-Describe               ^           |
*   +-Allocate               |  Static   |
*   +-Cache IDs              ^<----------*
*   +-....                   |           |
*                            |  Dynamic  |
*                    .------+--------.   |
*                    | Update Handle |<--'
*                    '---------------'
*************************************************************
[Figure [diagram]: Intended Render loop approach for SqueLib users.]

This mention of approach on the pipeline is followed in the next example:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
// LearnOpenGL Example1 - VertexArray Triangle
// https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp
const char* vert_source = "...";
const char* frag_source = "...";
float vertices[] = {
        -0.5f, -0.5f, 0.0f, // left  
         0.5f, -0.5f, 0.0f, // right 
         0.0f,  0.5f, 0.0f  // top   
    };  
// SqueLib
struct SQUE_Mesh triangle;
struct SQUE_Shader vert_shader;
struct SQUE_Shader frag_shader;
struct SQUE_Program program;

SQUE_MESH_SetDrawConfig(&triangle, SQUE_TRIANGLES, SQUE_STATIC_DRAW);
SQUE_MESH_SetDataConfig(&triangle, 3)
SQUE_MESH_GenBuffer(&triangle);
SQUE_MESH_BindBuffer(&triangle);
SQUE_MESH_AddAttribute(&triangle, "aPos", SQUE_FLOAT, false, 3);
SQUE_MESH_SetLocations(&triangle);
SQUE_MESH_SendToGPU(&triangle, vertices);

SQUE_SHADERS_GenerateID(vert_shader, SQUE_VERTEX_SHADER);
SQUE_SHADERS_SetSource(vert_shader.id, vert_source);
SQUE_SHADERS_Compile(vert_shader.id);

SQUE_SHADERS_GenerateID(frag_shader, SQUE_FRAGMENT_SHADER);
SQUE_SHADERS_SetSource(frag_shader.id, frag_source);
SQUE_SHADERS_Compile(frag_shader.id);

SQUE_PROGRAM_GenerateID(&program.id);
SQUE_PROGRAM_AttachShader(program, vert_shader);
SQUE_PROGRAM_AttachShader(program, frag_shader);
SQUE_PROGRAM_Link(program.id);

SQUE_SHADERS_FreeFromGPU(vert_shader.id);
SQUE_SHADERS_FreeFromGPU(frag_shader.id);

while(RenderLoop)
{
    SQUE_PROGRAM_Use(program.id);
    SQUE_MESH_BindBuffer(&triangle);
    // SQUE_MESH_SendToGPU(triangle, <dynamic_set_of_vertices> );
    SQUE_RENDER_DrawVertices(triangle);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SqueLib should provide helper items around a traditional OpenGL 3.3 approach to rendering, but keep very close to base OpenGL. The objective is not alienate a novice OpenGL user or a person who is comfortable with the basics, instead embrace that approach and make it more independent of either being powered by OpenGL or OpenGLES.

As mentioned in the example, the syntax early on focuses on declaring how the different objects will be treated. The user should always know how the used objects should align and be configured, in case of dynamic objects that can also be configured during the `RenderLoop` as well.

Finally, all the classes provided have their members public for anyone to initialize directly in their own way, should any function be too simple to be worth calling. The objective of setting up everything in functions is to make any reader instantly understand what each line is doing.

On the following sections, each helper item provided for SqueLib and finally a list of passthrough functions supported.

#### Value Types

OpenGL uses their own enum values for defining mostly anything, and as a system for remapping macros was already setup for GLFW and EGL, it has been used for the enum values that SqueLib would passthrough to the user.

Such values can be found under `RENDER MACROS` sections in the *`sque_remap_macros.h`* file.

#### Initialization

Thanks to **GLAD [#W57]** and the fact that both GLFW and EGL provide the base context for OpenGL, the process of initializing OpenGL requires a single call by the library, as there won't be explicit use of extensions and keeping it as vanilla as possible makes it more approachable:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
#if defined OpenGL
    gladLoadGL();
#elif defined OpenGLES
    gladLoadGLES2Loader(/* EGL Process Address  */);
#endif
~~~~~~~~~~~~~~~~~~~~~~~~~~~~


What is a bit of a pain is merging shaders between `GLSL 320 es` and `core 330`, which really only differ in the header representation. For that, shaders loaded into SqueLib will have to explicitly not provide the header. Instead, during initialization a the header is written to a static string and when setting up the source code for compilation, that string is written as a header to the body provided:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
static char glsl_ver[64] = {'\0'};
// Init Header String
    int ver = GLVersion.major * 100 + GLVersion.minor * 10;
    const char* term = "\n";
#if defined OpenGLES
    term = " es\nprecision mediump float;\n";
#else 
    term = " core\n";
#endif
    sprintf(glsl_ver, "#version %d %s", ver, term);

// Inserting Header into Shader provided by user
    const char* strs[2] = { glsl_ver, shader_source };
    glShaderSource(shader_id, 2, strs, NULL);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#### Mesh Buffers

SqueLib defines a mesh as a structure that holds for the information for a set of vertices and indices, the information in each vertex can be configured through attributes and then send to GPU and used to be passed to the render operation. 
Spefifically, a SQUE_Mesh does not take ownership of the data but only the information about said data. it is task of the user to manage that CPU memory allocation.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
class SQUE_VertAttrib
{
public:
	SQUE_VertAttrib();
	SQUE_VertAttrib(const char* name_, int32_t var_type, bool normalize, uint16_t num_components);
	~SQUE_VertAttrib();

	int32_t id = 0;
	int32_t var_type = SQUE_FLOAT;
	uint16_t num_comp = 0;
	bool normalize = false;
	uint16_t var_size = 4;
	uint16_t offset = 0;

	char name[89] = ""; // To align the class to 128 bytes
};

class SQUE_Mesh
{
public:
	SQUE_Mesh();
	~SQUE_Mesh();

	int32_t draw_config;
	int32_t draw_mode = SQUE_STATIC_DRAW;
	uint32_t attribute_object = 0;																													
	uint32_t vert_id = 0;
	uint32_t num_verts = 0;
																											
	uint32_t index_id = 0;
	uint16_t num_index = 0;
	uint32_t index_var = SQUE_UINT;							
	uint16_t index_var_size = 0;

	uint16_t vertex_size = 0;
    sque_vec<SQUE_VertAttrib> attributes;
};

void SQUE_MESH_SetDrawConfig(SQUE_Mesh* mesh, int32_t draw_config, int32_t draw_mode);
void SQUE_MESH_SetDataConfig(SQUE_Mesh* mesh, uint32_t num_verts, uint32_t num_index_ = 0, uint32_t index_var_ = SQUE_UINT);
void SQUE_MESH_AddAttribute(SQUE_Mesh* mesh, const char* name_ int32_t var_type, bool normalize, uint16_t num_components);

uint16_t SQUE_MESH_CalcVertSize(SQUE_Mesh* mesh);
uint16_t SQUE_MESH_GetAttribSize(SQUE_Mesh* mesh, const char* name);
void SQUE_MESH_SetLocations(SQUE_Mesh* mesh);

SQ_API void SQUE_MESH_GenBufferIDs(const uint32_t num, uint32_t* ids);
SQ_API void SQUE_MESH_GenAttributeObjects(const uint32_t num, uint32_t* attribute_objects);
SQ_API void SQUE_MESH_GenBuffer(SQUE_Mesh* mesh);
SQ_API void SQUE_MESH_BindBuffer(const SQUE_Mesh& mesh);
SQ_API void SQUE_MESH_BindVertices(const uint32_t vert_id);
SQ_API void SQUE_MESH_BindIndices(const uint32_t index_id);
SQ_API void SQUE_MESH_BindAttributeObject(const uint32_t attribute_object);
SQ_API void SQUE_MESH_SendToGPU(const SQUE_Mesh& mesh, void* vert_data = NULL, void* index_data = NULL);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<!--
~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-->

#### Textures

Textures accomplish the same objective as the Mesh class, hold the basic information regarding a texture buffer without taking control of the memory.

The attributes behave a bit different. Texture parameters are descriptors on how to take care of different operations, as such some of these operations require multiple values of either integer or float values.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
class SQUE_TexAttrib
{
public:
	SQUE_TexAttrib();
	SQUE_TexAttrib(const char* name, int32_t attrib_id, int32_t value);
	SQUE_TexAttrib(const char* name, int32_t attrib_id, float value);

	char name[28] = ""; // Align to 64bytes
	uint32_t type = UINT32_MAX;
	int32_t id = UINT32_MAX;
	void* data = NULL;	
};

struct SQUE_Texture
{
	uint32_t id = 0;
	int32_t dim_format = -1;
	int32_t use_format = -1;
	int32_t data_format = -1;
	int32_t var_type = SQUE_UBYTE;
	uint16_t var_size = 1;

	int32_t w = 0, h = 0;
	int32_t channel_num = 4;

	sque_vec<SQUE_TexAttrib> attributes;
};
void SQUE_TEXTURE_SetFormat(SQUE_Texture* texture, const int32_t dimentions_format, const int32_t use_f, const int32_t data_f, const int32_t var_type);
void SQUE_TEXTURE_SetDimentions(SQUE_Texture* texture, int32_t width, int32_t height, int32_t num_channels);
void SQUE_TEXTURE_AddAttribute(SQUE_Texture* texture, const char* name, int32_t attrib_id, int32_t value);
void SQUE_TEXTURE_AddAttribute(SQUE_Texture* texture, const char* name, int32_t attrib_id, float value);

SQ_API void SQUE_TEXTURE_GenBufferIDs(const uint32_t num, uint32_t* tex_ids);
SQ_API void SQUE_TEXTURE_GenMipmaps(const uint32_t texture_type);
SQ_API void SQUE_TEXTURE_Bind(const uint32_t texture_id, const int32_t texture_dims);
SQ_API void SQUE_TEXTURE_ApplyAttributes(const SQUE_Texture& tex);
SQ_API void SQUE_TEXTURE_SetActiveUnit(int32_t unit);
SQ_API void SQUE_TEXTURE_SendAs2DToGPU(const SQUE_Texture& tex, void* pixels, int32_t mipmap_level = 0);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#### Shaders and Programs

Shaders differ a bit form the other types, they only have to hold what type they are and the identifier. The actual file or code passed to compile is user dependant and as such they should take care of it.
It is the Program that actually holds the information for execution, and as such it has a container for the shader is linked to as well as the uniforms.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
struct SQUE_Uniform
{
	int32_t id = -1;
	uint32_t type = -1;
	int32_t var_size = 0;
	char name[56] = "";
};

struct SQUE_Shader
{
	int32_t id = 0;
	int32_t type = NULL;
};

SQ_API void SQUE_SHADERS_GenerateID(SQUE_Shader* shader, const int32_t shader_type);
SQ_API void SQUE_SHADERS_SetSource(int32_t shader_id, const char* source_);
SQ_API void SQUE_SHADERS_Compile(int32_t shader_id);
SQ_API void SQUE_SHADERS_FreeFromGPU(int32_t shader_id);

struct SQUE_Program
{
// Variables
	uint32_t id = 0;
	uint32_t shaders[2]; 
	sque_vec<SQUE_Uniform> uniforms;
	// IDs of the shaders // Order by execution stage
	// 0 Vertex -> 1 Fragment 
	// Geometry will not be implemented
    // Tessellation and Compute require extensions of OpenGLES which will also fall out of scope
};

void SQUE_PROGRAM_AttachShader(SQUE_Program* program, const SQUE_Shader shader);
void SQUE_PROGRAM_FreeShadersFromGPU(int32_t shaders[]);
void SQUE_PROGRAM_CacheUniforms(SQUE_Program* program);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Instead of having to query OpenGL during runtime, each program can choose to cache the uniforms after the linking process in order to have access directly to the id of a uniform.

During the render operation, the following uniforms are provided as a base as well as the function to retrieve the uniform id from the Program cached ones. The syntax uses a string and comparation to find the value, but should the user need it it could hold onto the ids after caching them and call use them directly.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
int32_t SQUE_PROGRAM_GetUniformID(const SQUE_Program& program, const char* uniform_name);

void SetBool	(const int32_t uniform_id, const bool value);
void SetInt		(const int32_t uniform_id, const int32_t value);
void SetFloat	(const int32_t uniform_id, const float value);
void SetFloat2  (const int32_t uniform_id, const float value[2]);
void SetFloat3	(const int32_t uniform_id, const float value[3]);
void SetFloat4	(const int32_t uniform_id, const float value[4]);
// ... add a matrix/array passer...																									
void SetMatrix4(const int32_t uniform_id, const float* matrix, const uint16_t number_of_matrices = 1, const bool transpose = false);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#### Framebuffers

One thing that I have learned through the optional subject *Advanced Graphics Programming*, is that it was extremely important to provide a way to manage also multiple framebuffers for mostly every possible approach of contemporary rendering techniques (separate from Compute oriented).

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
struct SQUE_Framebuffer
{
	uint32_t id;
	int32_t type; // Read, Write, Default

	uint32_t width, height;

	uint32_t depth_buffer_id;
	int32_t depth_type;

	uint32_t stencil_buffer_id;
	int32_t stencil_type;

	sque_vec<SQUE_Texture> textures;
};

void SQUE_FRAMEBUFFER_GenerateID(uint32_t* framebuffer_id);
void SQUE_FRAMEBUFFER_Bind(const int32_t type, const uint32_t id);
void SQUE_FRAMEBUFFER_GenRenderTypeID(uint32_t* renderbuffer_id);
void SQUE_FRAMEBUFFER_BindRenderType(const uint32_t renderbuffer_id);
void SQUE_FRAMEBUFFER_SetRenderTypeInfo(const uint32_t type, const uint32_t width, const uint32_t height);
void SQUE_FRAMEBUFFER_AttachRenderType(const uint32_t attachment_type, const uint32_t attachment_id);
void SQUE_FRAMEBUFFER_AttachTexture(const uint32_t dest_attachment, const uint32_t texture_id, const uint32_t mipmap_level = 0);
void SQUE_FRAMEBUFFER_SetDrawBuffers(const uint32_t attachments[], const uint32_t size = 1);
void SQUE_FRAMEBUFFER_CheckStatus();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By how OpenGL sets it up, a `Framebuffer` holds what draw data will be written to, and then used during the next render operation. A specific is that each type of draw buffer has to be set up separately in a traditional way. For that, generic `Renderbuffer` functions are setup although there are only provided a `depth_buffer` and a `stencil_buffer` in the struct.

Additionally, a `SQUE_Framebuffer` holds the texture data for the textures it reads and writes to. That is by the rationale that is if you are using a framebuffer to write and read to multiple textures the user should always have access to it when binding such textures to in or out values for the render operations.

#### State Control

In OpenGL it is very important to keep track of how each step of rendering is setup. Some passes require reading depth values, some other need to blend with the previously written layers and more. In order to make the user's life easier this class is provided:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
class SQUE_RenderState				
{	
public:
	SQ_API SQUE_RenderState(){};
	SQ_API ~SQUE_RenderState(){};

	bool backed_up = false;								
	
    int32_t blend_equation_rgb, blend_equation_alpha;
    
	bool blend_func_separate = false;
	int32_t blend_func_src_rgb, blend_func_dst_rgb;							
	int32_t blend_func_src_alpha, blend_func_dst_alpha;

	int32_t polygon_mode[2];									
	bool blend, cull_faces, depth_test, scissor_test;

	void SetUp();		
	void BackUp();							
};	
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`BackUp` copies the currently setup state according to the provided state variables. `SetUp` updates the OpenGL state with the values the user either backed it up with or they provided individually.

Good practice would be to back up once with the default pipeline state and then initialize the desired values.

#### OpenGL Functionality

As providing all of OpenGL's functionality is decidedly out of scope given the approach to perform the initialization library side instead of user side, thus making the user interface with SqueLib instead of OpenGL directly, a minimum valuable subset of functions are passed through for the user to interact with OpenGL as they would normally in an entry level environment.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
void SQUE_RENDER_ChangeFramebufferSize(int32_t width, int32_t height);		
void SQUE_RENDER_GetFramebufferSize(int32_t* width, int32_t* height);
void SQUE_RENDER_Clear(const ColorRGBA& color_rgba, int clear_flags = SQUE_COLOR_BIT);
void SQUE_RENDER_Scissor(int x, int y, int w, int h);
void SQUE_RENDER_GetViewport(int32_t* x, int32_t* y, int32_t* w, int32_t* h);
void SQUE_RENDER_GetIntV(int32_t value_id, int32_t* value);
void SQUE_RENDER_SetViewport(int x, int y, int w, int h);
void SQUE_RENDER_SetPolyMode(int32_t faces, int32_t mode);	
void SQUE_RENDER_BindSampler(int32_t texture_locator, int32_t sampler_id);

void SQUE_RENDER_DrawIndices(const SQUE_Mesh& mesh, const int32_t offset_indices = 0, int32_t count = -1);
void SQUE_RENDER_DrawVertices(const SQUE_Mesh& mesh, const int32_t count = 0);

// Debugging
void SQUE_SHADERS_CheckCompileLog(const int32_t shader_id);
void SQUE_PROGRAM_CheckLinkLog(const uint32_t program_id);
void CheckForRenderErrors(const char* file, int line);
void InitGLDebug();
#define SQUE_CHECK_RENDER_ERRORS() CheckForRenderErrors(__FILE__, __LINE__)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Specifically `SQUE_RENDER_DrawIndices` and `SQUE_RENDER_DrawVertices` use the `SQUE_Mesh` class that the user set up when declaring the object to send the information to OpenGL.

### File Management

As stated previously, the objective of the file management part of the library is to help the user read and write files to disk seamlessly throughout the supported platforms. By no means should the library ever take care of the memory that user allocates, provide utility for the basic use cases.

Such cases would be: read files, write files, create directories and manage the state of a file in disk (aka file-watching).

#### Basic Provided Structs

In order to interact with the filesystem, the following structs are provided:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
struct SQUE_Dir
{
	uint32_t id = UINT32_MAX;
	char name[64];
	char location[512];

	uint32_t parent_id = -1;
	sque_vec<uint32_t> children_ids;
};

SQUE_Dir SQUE_FS_GenDir(const char* location, const uint32_t parent_id = -1)
{
	SQUE_Dir d;
	d.id = SQUE_RNG();
	const char* tmp = strrchr(location, '.');
	if (tmp != NULL)
	{
		uint32_t l = SQUE_FS_GetParentDir(location);
		l = (l < sizeof(d.location)) ? l : sizeof(d.location);
		memcpy(d.location, location, l);
	}
	else
		memcpy(d.location, location, sizeof(d.location));

	memcpy(d.name, SQUE_FS_GetFileName(d.location), sizeof(d.name));

	return d;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A directory is setup to allow building directory trees easily, with a `uint32_t` handle for a parent and children and an own id for ease of traversal and discourage holding direct pointers to data.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
struct SQUE_Asset
{
	uint64_t size;
	char* raw_data;
};

struct SQUE_DataPack
{
    SQUE_Asset data;
    SQUE_Asset metadata;
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Just because such a type is very popular for use, a `SQUE_DataPack` englobes two generic assets that one should hold the actual data and the other one the descripting metadata of the asset.

#### Initialization

An easy to miss step to taking care of where to read and write files from is to setup a base directory from which to pivot. SqueLib will take the easiest available directory for reading and writing files from, which on desktop will be the working directory and on Android an external storage directory provided by the Android NDK:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
extern struct android_app* my_app;
static char exec_path[512];

void SQUE_FS_Init()
{
	int len = 0;
#if defined(_WIN32)
	len = GetModuleFileNameA(NULL, exec_path, 512);
	char* exe = strrchr(exec_path, FE);
	exec_path[len-strlen(exe)] = '\0';
#elif defined(ANDROID)
	sprintf(exec_path, "%s", my_app->activity->externalDataPath);
#elif defined(__linux__)
	char link_temp[512] = "\0";
	len = readlink("/proc/self/exe", link_temp, 512);
	const char* dir = dirname(link_temp);
	sprintf(exec_path, "%s", dir);
#endif
}

const char* SQUE_FS_GetExecPath()
{
	return exec_path;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The variable and retrieval function is named after execution path, as on desktop platforms that the easiest available directory and on Android such directory is unavailable to read and write from. On Android the storage directory is minimally hidden from the user and setup for an application to perform their external storage operation, although access to the whole system is available given the permissions.

Once that is set, Android behaves almost exactly as a Linux systems for the basic types of operations.

#### Android Assets

When building an Android based application, the source code, manifest files, resources and `assets` are packed and then installed in a protected directory. In said directory one can't write but only read through the Android NDK.

In order to not have an issue when reading and writting files a whole SqueLib application package is built with the expected *Asset* folder in the working directory with the structure set inside by the user. For that a generic read function and an *Asset* specialized functions are provided.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
SQUE_Asset* SQUE_FS_LoadAssetRaw(const char* file)
{
	SQUE_Asset* ret = NULL;
#if defined(ANDROID)
	ret = new SQUE_Asset();
	AAsset* asset = AAssetManager_open(my_app->activity->assetManager, file, AASSET_MODE_BUFFER);
	SQUE_PRINT(LT_INFO, "%d %s", asset, file);
	if(asset != NULL)
	{
		ret->size = AAsset_getLength(asset);
		char* tmp = new char[ret->size+1];
		memcpy(tmp, AAsset_getBuffer(asset), ret->size);
		tmp[ret->size] = '\0';
		ret->raw_data = tmp;
		AAsset_close(asset);
	}
	else
	{
		delete ret;
		ret = NULL;
	}
#else
	char* sprint_v = new char[256];
	int len = sprintf(sprint_v, "%s/Assets/%s\0", SQUE_FS_GetExecPath(), file);
	if (len > 256)
	{
		delete sprint_v;
		sprint_v = new char[len];
		sprintf(sprint_v, "%s/Assets/%s\0", SQUE_FS_GetExecPath(), file);
	}
	ret = SQUE_FS_LoadFileRaw(sprint_v);
	delete sprint_v;
#endif

	return ret;
}

SQUE_Asset* SQUE_FS_LoadFileRaw(const char* file)
{
	
	char* data = NULL;
	std::ifstream in;
	in.open(file, std::ios::binary | std::ios::in);
	if(!in) return NULL;
	in.seekg(0, std::ios::end);
	int len = in.tellg();
	in.seekg(0, std::ios::beg);
	data = new char[len+1];
	in.read((char*)data, len);
	in.close();

	SQUE_Asset* ret = new SQUE_Asset();
	ret->size = len+1;
	ret->raw_data = data;
	memcpy(&ret->raw_data[len], "\0", 1);
	
	return ret;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As can be seen, the `SQUE_FS_LoadFileRaw` perfoms a basic read operation and returns a basic struct with a generic pointer to the data and the size of it.
`SQUE_FS_LoadAssetRaw` perfoms a similar operation but specializes the search of the file inside the *Asset* directory built with the application for desktop platforms, on Android it uses the Android NDK provided approach for reading a generic file from the installed package.

#### Creating Directories

As the user should not always know the full path to where it wants to read or write, two base functions are provided:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~c++
bool SQUE_FS_CreateDirFullPath(const char* path)
{
    if(!(SQUE_AskPermissions("WRITE_EXTERNAL_STORAGE") && SQUE_AskPermissions("WRITE_MEDIA_STORAGE")))
        return false;
	bool ret = true;
#if defined(_WIN32)
	ret = CreateDirectoryA(path, NULL);
#elif defined(ANDROID) || defined(__linux__)
	ret = ret && mkdir(path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) > 0);
#endif
	return ret;
}

// Does not support navigating backwars "../~", relative to exec_path
bool SQUE_FS_CreateDirRelative(const char* path, int32_t flags)
{
	std::string exec_path = std::string(SQUE_FS_GetExecPath()) + FOLDER_ENDING + path;
	return SQUE_FS_CreateDirFullPath(exec_path.c_str());
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#### File Watching

Dealing with data at a large scale during runtime is very time consuming and annoying to do. Assuming that data inside the Android package will not change during runtime as write actions are not allowed and that external storage behaves very close or exactly to a Linux platform, we can use the C++17 `std::filesystem` library to perform such file-watch operations.

To take care of asset, the following struct is provided:

~~~~~~~~~~~~~~~~~~~~~~~~~c++
typedef void(ReadWriteAssetFun)(const char* location, SQUE_DataPack* datapack);
typedef void(UnloadAssetFun)(SQUE_DataPack* datapack);

struct SQUE_CtrlAsset
{
	// Static Data - Generated or Loaded
	uint32_t id = -1;
	char name[64] = "";
	char location[512] = "";
	uint32_t dir_id = UINT32_MAX;
	uint32_t type = -1; //?
	
	// Runtime Updates
	SQUE_Timer unused_timer;
	uint32_t current_users = 0;
	uint8_t status = 0; // 0 = not_changed, 1 = Changed, 2 = Deleted
	double last_update = 0;


	// Type Based functions  
	ReadWriteAssetFun* Save;
	ReadWriteAssetFun* Load;
	UnloadAssetFun* Unload;

	// Actual Data
	SQUE_DataPack datapack;
};
~~~~~~~~~~~~~~~~~~~~~~~~~

Every base asset will requires a description of location, naming and status during runtime. As every asset might behave differently, a callback that the user can set for saving, loading and unloading from memory is provided.With this class the user can set the implementation of the asset-disk interaction and the system to handle them comfortably.

~~~~~~~~~~~~~~~~~~~~~~~~~c++
class SQUE_FW_NewAsset
{
public:
	SQ_API SQUE_FW_NewAsset() {str = new char[512];};
	SQ_API ~SQUE_FW_NewAsset() {delete str;};

	double last_update = 0;
	uint32_t str_len = 0;
	char* str;
};

sque_vec<SQUE_FW_NewAsset>* SQUE_FS_CheckDirectoryChanges(const char* path, const sque_vec<SQUE_CtrlAsset*>& assets_in_dir, HandleNewAssetLocation* handle_fun)
{
    // Check for deleted items in the passed vector of assets
    for (uint32_t i = 0; i < assets_in_dir.size(); ++i)
	{
		assets_in_dir[i]->status = 0;
		if (!std::filesystem::exists(assets_in_dir[i]->location))
			assets_in_dir[i]->status = 2; // Asset does not exist in disk
	}
    // Setup return vector of newly created items
	sque_vec<SQUE_FW_NewAsset>* new_items = new sque_vec<SQUE_FW_NewAsset>();
    // Perform a search in each directory from the base directory provided
    // Check against existing items with the files found in the recursive search
	for (auto& file : std::filesystem::recursive_directory_iterator(path))
	{
        // If a file is found, an early exit is taken
		uint32_t i;
		for (i = 0; i < assets_in_dir.size(); ++i)
		{
			if (assets_in_dir[i]->status == 2) continue;
			if (strcmp(assets_in_dir[i]->location, file.path().string().c_str()) == 0)
				break;
		}
		if (i < assets_in_dir.size()) // If early exit AND update times don't match
		{
			double last_update = (double)std::chrono::duration_cast<std::chrono::seconds>(file.last_write_time().time_since_epoch()).count();
			if (last_update != assets_in_dir[i]->last_update)
			{
				assets_in_dir[i]->last_update;
				assets_in_dir[i]->status = 1; // Set to Update
			}
		}
		else // File is not in the list of assets, add it to vector of new locations
		{
			new_items->push_back(SQUE_FW_NewAsset());
			SQUE_FW_NewAsset* a = new_items->last();
			memcpy(a->str, file.path().string().c_str(), 512);
			a->str_len = file.path().string().length();
		}
	}
	return new_items;
}
~~~~~~~~~~~~~~~~~~~~~~~~~

Then a way to generate a directory tree very easily:

~~~~~~~~~~~~~~~~~~~~~~~~~c++
void SQUE_FS_GenDirectoryStructure(const char* location, sque_vec<SQUE_Dir>* dirs)
{
    void SQUE_FS_GenDirectoryStructure(const char* location, sque_vec<SQUE_Dir>* dirs)
{
	dirs->push_back(SQUE_FS_GenDir(location));

	for (auto& file : std::filesystem::recursive_directory_iterator((*dirs)[0].location))
	{
		if (file.is_directory())
		{
			dirs->push_back(SQUE_FS_GenDir(file.path().string().c_str()));
			dirs->last()->parent_id = AddToParent(dirs->last()->id, dirs->last()->location, *dirs);
		}
	}
}
~~~~~~~~~~~~~~~~~~~~~~~~~

These two helpers should allow every c++ low level user have a file watching system very quickly up and running. One thing I dislike currently is that the return value is a structure with allocated strings.
To avoid issues with memory and not having to use heavy-weight classes, a simple wrapper for the vector return is provided.

The user will access `str` and `str_len` for location and then `last_update` for the newly created asset. A copy return value on a probably heavy vector would be horrible, as such the vector holds pointer data not the whole stack adn the wrapper struct manages the deletion on delete call of the vector.

#### Stream Read and Write

The process of reading and writing custom binary files is not very friendly to most users, at least with out-of-the box C++. Continuing the theme of the library, two simple classes are provided for a bit easier introduction to binary serialization.

Only the important steps of serialization are shown in the following code snippet:

~~~~~~~~~~~~~~~~~~~~~~~~~c++
class SQUE_OutStream
{
    //...
template<class T>
	void WriteBytesAt(const T* from, uint64_t at, uint32_t num_items = 1)
	{
		uint64_t end_write = at + sizeof(T) * num_items;
		if (_capacity < end_write) reallocate(end_write * 2);
		memcpy(&_data[at], from, sizeof(T) * num_items);
		if (at + sizeof(T) * num_items > _size) _size = end_write;
	}

	template<class T>
	void WriteBytes(const T* from, uint32_t num_items = 1)
	{
		uint64_t end_write = _size + sizeof(T) * num_items;
		if (_capacity < end_write) reallocate(end_write * 2);
		memcpy(&_data[_size], from, sizeof(T) * num_items);
		_size = end_write;
	}
    //...
};

class SQUE_InStream
{
    //...
    void AttachAsset(SQUE_Asset* asset) { _data = asset; _readpos = _data->raw_data; _readpos_n = 0; }

	template<class T>
	void ReadBytesAt(T* to, uint32_t num_items, uint64_t at)
	{
        assert(at+(num_items * sizeof(T)) < _data->size);
		memcpy(to, &_data->raw_data[at], num_items * sizeof(T));
	}

	template<class T>
	void ReadBytes(T* to, uint32_t num_items)
	{
		memcpy(to, &_data->raw_data[_readpos_n], num_items * sizeof(T));
		_readpos_n += num_items * sizeof(T);
	}
    //...
};
~~~~~~~~~~~~~~~~~~~~~~~~~

A `SQUE_OutStream` is used to write a buffer that will be then written to disk using the preffered function. `WriteBytes` will write bytes specifically at the end of the buffer and keep incrementing it, while `WriteBytesAt` allow the use to write where he pleases.

A `SQUE_InStream` is attached to a `SQUE_Asset` that has been already read from disk. `ReadBytes` will read sequentially given the templated arguments and such data will be copied over to an out variable.`ReadBytesAt` will read where the user decides to, while making sure the user does not read memory outside of bounds.

## Utilities

The core library is provided alongside with a couple utilities or implementations that seemed interesting to strengthen again the knowledge in C++ and programming general. Not every utility is directly targetted a subset of users but more of an interest found during the production.

### Logging

Loggin with SqueLib is similar to a subsystem, you initiate it, act on it and then close it. Specifically, on closure the log subsystem will dump the logs written on disk.

~~~~~~~~~~~~~~~~~~~~~~~~~c++
#define LOGSIZE 1024
struct SQUE_Log				
{		
	int type = -1;
	SQUE_LogType lt = LT_INFO;
	char log[LOGSIZE] = {0};						
};
typedef std::pair<int, SQUE_Log> PairLOG;

bool SQUE_LOGGER_Init(bool dumpdata);
void SQUE_LOGGER_Close();
void SQUE_LOGGER_DumpData();

void SQUE_LOGGER_Log(SQUE_LogType lt, const char file[], int line, const char* format, ...);
#define SQUE_LOG(LogType,format,...) SQ_MACRO SQUE_LOGGER_Log(LogType,__FILE__,__LINE__, format, ##__VA_ARGS__)

const std::unordered_map<int, std::string>& SQUE_LOGGER_GetKeys();
const sque_vec<PairLOG>& SQUE_LOGGER_GetLogs();

// Not directly accessible to user
static std::unordered_map<std::string, int> Push_LogKeys;
static std::unordered_map<int, std::string*> Get_LogKeys;
static sque_vec<PairLOG> logs;
~~~~~~~~~~~~~~~~~~~~~~~~~

The implementation is based on an ID system from the file a log came from, similarly to the console printing, it makes use fo the `__FILE__` and `__LINE__` macro to know where the call originated from and extracts the filename to use as a key in a `std::unordered_map` to insert into groups of logs.
The idea is that said map can be read on an ordered timeline and be filtered by the file it originated from to reduce the complexitiy of reading the logs either offline or during runtime.

### Timer

During the coursing of the past programming subjects in the degree, it felt extremely important to have a very good in-engine tool for dealing with timings. Most tools and libraries for profiling will probably be external but for some quick usage a custom class felt a necessary.

The current implementation is based on `std::chrono` for time reads and then translate to a timer style read at milliseconds, microseconds and nanoseconds, although the precision depends on the OS's implementation of reporting timings:

~~~~~~~~~~~~~~~~~~~~~~~~~c++
class SQUE_Timer
{
public:
	SQUE_Timer();

	void Start();
	void Stop();
	void Kill();
	bool IsStopped() const;		
	bool IsActive() const;
	double ReadMilliSec() const;
	double ReadMicroSec() const;
	double ReadNanoSec() const;	
private:
    // vars ...
};	
~~~~~~~~~~~~~~~~~~~~~~~~~

### Data Structures

Spending time on the internet learning about programming will cloud the point fo view for most users when dealing with C++. The standard library is a great set of functionality for a new user but at the same time is very convoluted and has a lot landmines that professionals know to avoid.

I am not one of those and one of the big criticisms was the implementation of the basic structures. In order to understand a bit more as well as taking little step into understanding optimization and coding pitfalls, the following structures have been implemented:

 * **sque_vec<>** : Analogous to a std::vector<>. Not implemented to work with jagged arrays, because of lack of understanding on them.
 * **sque_dyn_arr<>** : Intention is to make an array that can just be increased in size, such implementation could be complementary to a XMacro system with plugins that add to them as they could query the entry amount and add an item and save for the location to use as fake enum value.
 * **sque_free_vec<>** : A vector based on unknow location push, to allow freeing spaces of memory and filling them up. The idea is that of a vector that is a bit more memory conscious.
 * **sque_list<>** : Analogous to a std::list<>

By no means it is claimed that these structures are better that the ones available on the standard library or on other vendors' implementations, the objective is that of understanding such implementations and be comfortable with dealing with custom implementations in the future.

### Sorting Algorithms

A thing that has faltered during these years as a programmer that around other areas seems to be common knowledge, is the understanding of complexity of an algorithm. The *O Notation* has not been properly introduced. Sorting algorithms felt like a great entry to such notation explanation and implementation seemed ideal for getting introduced to.

Under the `sque_sort.h` the following subset of templated sorting algorithms with a short explanation on how they work, are provided:

 * Selection Sort
 * Bubble Sort
 * Insertion Sort
 * Merge Sort
 * Quick Sort

### Dear ImGui Backend for SqueLib

Dear ImGui does not have an official direct backend for Android, although there is one floting in the issues<sub>[#W58]</sub> which has been used to adapt the SqueLib one. A good way to make easily recognizable progress on Android was to make such a backend available as an OpenGL/GLFW user could not just simply use the existing samples given that SqueLib sets the access to those libraries as private.

The following basic functions are provided and are to be used following the provided example with SqueLib:

~~~~~~~~~~~~~~~~~~~~~~~c++
IMGUI_IMPL_API void ImGui_ImplSqueLib_Init();        // After ImGui::CreateContext()
IMGUI_IMPL_API void ImGui_ImplSqueLib_Shutdown();    // Before ImGui::Shutdown() if still using that
IMGUI_IMPL_API void ImGui_ImplSqueLib_NewFrame();    // Before ImGui::NewFrame(), It will not process inputs, just read, you have to process them
IMGUI_IMPL_API void ImGui_ImplSqueLib_Render(ImDrawData* draw_data); // After ImGui::Render(), and remember to clear framebuffer!
~~~~~~~~~~~~~~~~~~~~~~~

Full keyboard, software keyboard, touch and mouse functionality is provided for ImGui. Viewports are not supported as SqueLib does not provide multiwindows. The version of ImGui it is based on is v1.82.

## Extra libraries

The following libraries can be built with SqueLib by defining their required options, provided in the _/extra_ directory and will help with frequent uses for application development:

| Library | CMake Option | Short Description |
|---|---|---|
| SoLoud<sub>[#W47]</sub> | *WITH_SOLOUD* | Very simple yet powerful audio engine with a plethora of backends. Recommended use with the MiniAudio backend which is included and works in multiple platforms including Android, Windows and most major Linux Distros. |
| GLMath<sub>[#W48]</sub> | *WITH_GLM* | Math library geared towards OpenGL use, with classes and operation for vectors, quaternions, matrices and mostly every use case found in computer graphics. |
| MMGR<sub>[#W49]</sub> | *Debug* AND *WITH_MMGR* | Single threaded memory manager, which outputs the allocations and deallocation pairs to make sure memory is properly kept in check. |
| Dear ImGui<sub>[#W50]</sub> | *WITH_IMGUI* | High performance Immediate Mode User Interface library written in platform agnostic C++ |

# SqueLib Sample Projects

## Performance Tests

## SquePong

## Dear ImGui with SqueLib

## LearnOpenGL introduction with SqueLib

# SqueMaker Development

<!-- Talk about testing what SqueLib can do in practice as well as taking steps into designing a competent tool for making games -->

## Entity Component System

## Engine UI

## Render Pipeline

## Serialization

## Scripting System

# SqueMaker Sample Projects

# Conclusions

# Webgraphy
<!-- 
[#WX]: Title: Description. Author, Year.
<url> 
-->

[#W1]: SqueLib: A C++ multiplatform library and framework. Marc Torres Jimenez, 2021.
<https://github.com/MarcFly/SqueLib>

[#W2]: SqueMaker: A C++ game engine based on SqueLib. Marc Torres Jimenez, 2021.
<https://github.com/MarcFly/SqueMaker>

[#W3]: KDE. KDE e.V., 1998.
<https://kde.org/>

[#W4]: The 3-Clause BSD License. Regents of the University of California, 1999. 
<https://opensource.org/licenses/BSD-3-Clause>

[#W5]: Open Source Software. Open Source Initiative, 1998.
<https://opensource.org/>

[#W6]: Unity. Unity Technologies, 2005.
<https://unity.com/> 

[#W7]: Unreal Engine. Epic Games, 2014.
<https://www.unrealengine.com/en-US/> 

[#W8]: Godot. Juan Linietsky and Ariel Manzur, 2014.
<https://godotengine.org/showcase> 

[#W9]: Source available, Open Source, Free Software. Phil Haack, 2006.
<https://haacked.com/archive/2006/07/26/CodeAvailableVsOpenSourceVsFreeSoftware.aspx/>

[#W10]: GDevelop. Florian Rival et al, 2008.
<https://gdevelop-app.com/>

[#W11]: Cocos Creator. Chukong Technologies, 2019.
<https://www.cocos.com/creator> 

[#W12]: Defold. Ragnar Scensson and Christian Murray, 2007.
<https://defold.com/> 

[#W13]: Lumberyard. Amazon, 2016.
<https://aws.amazon.com/es/lumberyard/> 

[#W14]: Awesome Cpp. fffaraz, 2015.
<https://github.com/fffaraz/awesome-cpp>

[#W15]: EGL. Khronos Group, 2014.
<https://www.khronos.org/egl>

[#W16]: OpenGL. Silicon Graphics Inc, 1992.
<https://www.opengl.org/>

[#W17]: OpenGLES. Khronos Group, 2002.
<https://www.khronos.org/opengles/>

[#W18]: GLFW. GLFW Development Team, 2002.
<https://www.glfw.org/>

[#W19]: Simple DirectMedia Layer. SDL Community, 1998.
<https://www.libsdl.org/>

[#W20]: RayLib. Ramon Santamaria et al, 2013.
<https://www.raylib.com/>

[#W21]: Android NDK. Google, 2009.
<https://developer.android.com/ndk>

[#W22]: Gitkraken. Axosoft, 2015.
<https://www.gitkraken.com/>

[#W23]: Game Maker Studio 2. YoYo Games, 2016.
<https://www.yoyogames.com/get>

[#W24]: Gantt Project. Alexandre Thomas et al, 2003.
<https://www.ganttproject.biz/>

[#W25]: HacknPlan. Christian Estévez López et al, 2015.
<https://hacknplan.com/>

[#W26]: Rawdraw. CNLohr et al, 2013.
<https://github.com/cntools/rawdraw>

[#W27]: ColorChord. CNLohr, 2015.
<https://github.com/cnlohr/colorchord>

[#W28]: Difference in Temporal versus Full time Contracts. Instituto Nacional de Estadistica, 2017.
<https://www.ine.es/jaxiT3/Datos.htm?t=10919>

[#W29]: Salary of non-public office worker. Instituto Nacional de Estadistica, 2017.
<https://www.ine.es/jaxiT3/Datos.htm?t=10916>

[#W30]: Rawdraw Android. CNLohr, 2020.
<https://www.youtube.com/watch?v=Cz_LvaN36Ag>

[#W31]: KDevelop. KDE, 1999.
<https://userbase.kde.org/KDevelop4/Manual>

[#W32]: Asus Zenfone 2 Specs. Asus, 2015.
<https://www.gsmarena.com/asus_zenfone_2_ze551ml-6917.php>

[#W33]: Intel Atom discontinuation for Android. Article by Daniel Moran, 2016.
<https://www.xda-developers.com/intel-myths-debunked-atom-is-not-dead-and-not-leaving-mobile/>

[#W34]: Android Platform Distribution. Google, 2021.
<https://developer.android.com/about/dashboards/index.html#OpenGL>

[#W35]: Using the NDK with other build Systems. Google, 2021 (last update).
<https://developer.android.com/ndk/guides/other_build_systems#overview>

[#W36]: GNU Linker Documentation. GNU, 2009.
<https://linux.die.net/man/1/ld>

[#W37]: GNU Compiler Option Index. GNU, 2001.
<https://gcc.gnu.org/onlinedocs/gcc/Option-Index.html> 

[#W38]: Best and Worst Compiler Flags for Embedded Systems. Chris Coleman, 2019.
<https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags#-ffunction-sections--fdata-sections----gc-sections>

[#W39]: So what exactly is -ffunction-sections and how does it reduce binary size?. Vidar Holen, 2018.
<https://www.vidarholen.net/contents/blog/?p=729>

[#W40]: CMake Documentation: add_custom_target. Kitware, 2021.
<https://cmake.org/cmake/help/latest/command/add_custom_target.html>

[#W41]: Envsubst Documentation. GNU, 2020.
<https://www.gnu.org/software/gettext/manual/html_node/envsubst-Invocation.html>

[#W42]: AAPT2 Documentation. Google, 2020.
<https://developer.android.com/studio/command-line/aapt2#link_options>

[#W43]: Jarsigner Documentation. Oracle, 2020.
<https://docs.oracle.com/javase/7/docs/technotes/tools/windows/jarsigner.html>

[#W44]: Zip Linux Documenation. Info-ZIP, 2008.
<https://linux.die.net/man/1/zip>

[#W45]: Zipalign. Google, 2021/
<https://developer.android.com/studio/command-line/zipalign>

[#W46]: Android Debug Bridge Documentation. Google, 2021.
<https://developer.android.com/studio/command-line/adb>

[#W47]: SoLoud. Jari Komppa, 2020.
<https://sol.gfxile.net/soloud/>

[#W48]: MMGR and other Utilities. Paul Nettle, 2000.
<https://www.flipcode.com/archives/Presenting_A_Memory_Manager.shtml>

[#W49]: GLMath. G-Truc, 2020.
<https://github.com/g-truc/glm>

[#W50]: Dear ImGui. Omar Cornut, 2021.
<https://github.com/ocornut/imgui>

[#W51]: Rawdraw Android Makefile. CNLohr, 2020.
<https://github.com/cnlohr/rawdrawandroid/blob/master/Makefile>

[#W52]: Android Build Numbers. Google, 2021.
<https://source.android.com/setup/start/build-numbers>

[#W53]: Android NDK Samples. Google 2020.
<https://developer.android.com/ndk/samples/sample_na>

[#W54]: Android NDK Log. Google 2020.
<https://developer.android.com/ndk/reference/group/logging>

[#W55]: beautiful Native Libraries. Armin Ronacher, 2013.
<https://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/>

[#W56]: LearnOpenGL. Joey de Vries, 2014.
<https://learnopengl.com/Introduction>

[#W57]: GLAD. Dav1dde, 2013.
<https://github.com/Dav1dde/glad>

[#58]: ImGui Android, Issues. stawrocek, 2017.
<https://github.com/ocornut/imgui/issues/1200>

<script src="markdeep-thesis/lib/bindery/2.2.9/bindery.min.js"></script>
<script>
    markdeepThesisOptions = {
        view: "print",
        titlePage: titlePage,
        fontSize: 11,
        extraBinderyRules: [

        ],
        runningHeader: function (page) {
            if(page.heading.h1 == undefined)
                return ``
            else
                return `${page.heading.h1}~ ${page.number}`
        },
        markdeepDiagramScale: 0.8
    }
</script>

<script src="markdeep-thesis/markdeep-thesis.js"></script>

<script src="markdeep-thesis/lib/markdeep/1.11/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
<meta charset="utf-8" lang="en">

<script>
var titlePage = {
      institution: "Universitat Politécnica de Catalunya"
    , institutionExtra: `Centre de la Imatge i Tecnologia Multimèdia`
    , thesisKind: "Bachelor's Thesis in Game Development"
    , thesisTitle: "SqueLib: C++ for multiplatform development"
    , thesisSubtitle: "Cultivating a learning environment"
    , thesisAuthor: "Marc Torres Jimenez"
    , thesisDate: "March 2021"
    , reviewers: [
          `Jesús Díaz García
           Senior Graphics Programmer
           Universitat Politècnica de Catalunya
          `
      ]
  }
</script>

(##) Abstract

Videogame development takes place not only on leading performance platforms, but primarily on emerging technologies and mobile platforms, relegating the priority on these classically more mature platforms to experiment on limits of current hardware and focusing on more lucrative endeavours on other platforms.

As C++ has been traditionally taught and learned for providing mainly computer experiences, a push for providing standardized environments for developing videogames and other kinds of applications have moved developers away from C++ and brought them to specialized software or other languages.

Although the impact of the C++ language diminishes as these alternatives grow in usage and more memory safe language options appear, which begin to rival its native performance, an approach to developing multiplatform experiences with a core language seems to be lost.

SqueLib<sub>[#W1]</sub> is a C++ library and framework to developing multiplatform C++ based applications that focuses on providing an quick introduction to multiplatform development to C++ developers who have traditionally focused on desktop platforms.

A second focus on SqueLib is its ease of expansion and integration with other libraries, allowing users to integrate into their project as a wrapper or as a founding stones of their project.

The result of the project provides SqueLib, examples on using SqueLib and SqueMaker<sub>[#W2]</sub>, a simple game engine which makes full use of the library. The process of implementation is also explained in this document. 

The engine will be provide both as a source code package and an executable that can be executed in any Windows machine and Ubuntu based Linux distributions (tested under KDE<sub>[#W3]</sub>).

The source code for the resulting projects will be open sourced under the BSD-3-Clause<sub>[#W4]</sub>, permitting redistribution of the source code providing the copyright notice, redistribution of the binary that reproduces the copyright notice for the project, without using such notice as an endorsement for the derived products.

(##) Keywords

C++, CMake, OpenGL, GLFW, EGL, Android, NDK, Windows, Linux, Multiplatform, Engine
(##) Project Links

**W1 -** SqueLib Github Repository<sub>[#W1]</sub>

**W2 -** SqueMaker Github Repository<sub>[#W2]</sub>

<!-- add links to resulting apps, games,... -->

(##) Glossary

| Term | Description |
|---|---|
| GPU | Graphics Processing Unit |
| API | Application Programming Interface |
| Full Stack | Pertaining to all areas of specific software development |

---

# Introduction

Every createor wants to create, be it products, tools, works of art or the specifically desired object of creation. In the software development industry the tradition has shifted from producing from scratch to producing for the creators and these creators to make use of the available tools and products to make their creations.

The contemporary landscape of videogame development focuses on the usage and mastery of game engines in order to produce works of art, which make full use of the available technology under an abstraction layer that obfuscates the inner workings from the developer. This abstraction, which is present in some way or another on any software development process, separates the creative potential form the creators from the lower level technical requirements.

This breakthrough in creative control comes at a cost of a long term drought on technologic savviness and locking these creatives into their chosen environments. When facing different challenges different tools must be used or even made up to tackle them, which is initially limited or locked for the users entering these environments.

Resulting from this thesis is an introduction on obtaining control on the process of development before being locked on the creative process, providing a knowhow into the continuous development of project outside the final product.

## Motivations

During the coursing of the Bachelor's Degree in Videogame Design and Development, the introduction to other platforms came at the cost of locking the user is specific environments which have mostly mirrored what can be easierly found when searching for alternatives, when working with C++.

If you want to work in Android you will be introduced to Java/Kotlin and Android Studio, if you want to work in Web Development you will be mostly forced into JavaScript, HTML and CSS and generating infinity dependecies.

As an opportunity to grow as a C++ programmer and provide a learning experience for others to come, the creation of a library that allows a faster introduction to these new environments without the buffer time of learning completely new environment and language, seem to fit me the most.

## Problem Statement

When developing a videogame, the target platforms from scratch C++ are initially limited or the expansion of target platforms increase the scope massively. Markets are not to be ignored in some projects but the cost of increasing the scope are very limiting to smaller productions.

SqueLib<sub>[#W1]</sub> aims to provide a base from which a smaller C++ based production can realy on to take care of the core subsystems that allow the project to execute on Android, Linux and Windows. As well as providing a learning experience in what hides under the process of having a C++ application run on multiple platforms without specific code on the developers' part.

The resulting project can be easily modified and integrated according to the developer's interests, a base solution that requires usage of SqueLib's systems without code rewriting for any platform and subsystems provided. 

On the other hand SqueMaker<sub>[#W2]</sub> targets the usage

## SqueLib Objectives

### General Objectives

The process of developing or increasing development scope to target multiple platforms is a tremendous headache when developing C++ based games, even when most widely available and used libraries are multiplatform capable by nature and most platform provide the mainly required components for running C++ compiled applications.

Non-desktop environments mostly lock their development libraries and APIs under licensing and development agreements, which makes the jump from an open environment to more obfuscated platforms hard.

Given these issues, the jump mostly goes from desktop development to product development in game engines and specific software. This project tries to provide an introduction to this development as well as creating a library that makes it easier to enter while keeping full control on technology and cretivity.

Main objectives for the this thesis include:
1. Design and Develop a multiplatform application building library for C++
2. Open Source the resulting project under BSD-3-Clause License<sub>[#W4]</sub>
3. A learning experience into multiplatform Development
4. Provide examples and demonstration for the subsystems of the library


### Specific Objectives

In order to provide this multiplatform entry without veering off C++, the library must not only provide the source C++ code but the wrapping elements that are necessary for working seamlessly on multiple environments, while not losing control over them.

**Window System** which pases full control over application's canvas and and sub-window creation.

**Rendering System** that makes relies silently on a graphics API which the user should not access directly but in a familiar fashion, which will allow the inclusion of further APIs if necessary.

**Input System** which makes interaction with any target platform not differ from other target systems.

**File Access System** that makes accessing the target platform's files trivial and easy.

**Sound System** 

## SqueMaker Objectives

### General Objectives

Developing games is hard, there are lots of areas of knowledge required to accomplish the creation of a videogame. Deepening the knowledge in the provided subsystems and having a playground to comfortably learn new about new areas, is essential to developing focused paths of success.

As a personal interest in learning more about each new topic of interest, it coincides with having an accessible engine which can be easily modified to learn about both older and emergin technologies.

Main objectives for the engine are:
1. Develop a toy engine to play with the provided subsystems and make simple games
2. Make a flexible engine that can accomodate new features and technologies
3. Be able to quickly iterate over the implemented technologies 

### Specific Objectives

As mentioned, the creation of a game requires knowledge in lots of areas. The creation of a tool that can make games requires the implementation of that knowledge and have it accessible to the end user.

**Rendering Pipeline** using the core provided by the library but remains flexible for developers, separated from the core of executing the application.

**Asset Management** robust enough to support constant iteration and secure to lessen the requirements of data management from the user.

**Entity Component System** that implements a somewhat flexible approach to managing neutral objects but specifically in a data oriented way, providing a strong base for performant systems. 

**Fast Logic implementation and iteration**, summarized in a non-locking environment for testing the logic code. Encourage the use of external tools but still maintain a strong link with the engine in order to debug and improve on the code.

## Project Scope

Both the creation of a stable library and making a game engine are not quick and eas jobs. Both require considerable amount of time to polish and have at state of the art, because of the wide area of knowledge required to make the feature complete.

Most custom engine target specific platforms with a speicifc set of tools and libraries which are provided. Making use of such tools and libraries are key to making the library fast to reach usable states and more stable releases, while the enigne relies more heavily on the constant implementation of usability features.

As the basis for this project thesis and the actual time available is limited and a single person will be working on it, instead of hundreds of talented individuals, cler cuts ahve to be made to have them on time.

The amount of features will be closely examined and mostly non-expanded or even cut over time. Making a playground includes room for creativity and innovation alongside the project instead of within the project.

Visual polish and accessibility might be cut down toto, althought it is an area of interest for making it more available as a learning environment.

Finally, it is important to remark that the introduction to a DIY culture in programming for game creators is of most importance in the project. Dealing with both interest in technology but lacking the options by misinformation is an issue that must be tackled, currently this project sets to give options towards DIY culture rather than transitioning to off-the-shelf engines or platform dedicated software for multiplatform development.

# State of the Art

Until the smartphone revolution consolidated itself with the iOS and Android operative systems were consolidated, crossplatform specific tools were close to non-existant. Videogames were developed for target platforms and later ported to other ones if it were expected to be a successful endeavour. 

Around that time multiplatform development were taken by dedicated porting studios for specific platforms, who continue to be relevant nowadays as both console systems and mobile platforms maintain somewhat of a barrier of entry.

At the same time, previous endeavours to make libraries or frameworks for specific subsystems have gained a ton of traction among the indie community as the porting services are not as attainable for them. Open access and resources available through OSS<sub>[#W5]</sub> is the driving force behind most academic and institutions development efforts as well as a strong pilar of lots of products developed.

The last approach which has gained the most traction are the generic game engines, meaning that the technologies provided are meant to be game genre agnostic and provide a base package from which any game can be created.

For project availability and focus of the thesis, OSS and widely available game engines will be taken into account, both of which bearing multiplatform capabilites for specific subsystems of the whole development of a game.

## C/C++ Open Source Software

As a C++ developer, there is a plethora of available open source libraries and frameworks for every subsystem and for full stack development. Most well known projects are great entry points for game development, as they provide great documentation and over the years a lot of community supported content for both experienced and new users.

Because of the extension of the open source landscape, the reviewed projects will fall under the most basic subsystems to get an application running and which I have previous knowledge of or experience with. For an explicitly extensive list of great open source projects in C++ refer to Awesome-Cpp<sub>[#W14]</sub>.

An introduction to the library or framework will be provided, as well as the reasons provided for its usage, or lack of it. Before that it is important to clear out the reasons behind not choosing the following feature complete libraries:

### Why not use SDL or RayLib?

Both SDL<sub>[#W19]</sub> and RayLib<sub>[#W20]</sub> are the contemporary standards for easier C and C++ open source game development libraries. Both offer a ton of content, documentation, examples and tutorials when supporting major platforms. The approach of this thesis is directly inspired by these libraries but with a research approach to what is required to accomplish their purpose.

When developing specifically for portability and facilitating iteration times, both libraries are the most versatiles out there, both with great community support, with RayLib getting constant updates and support for more platforms and programming language bindings.

Besides eliminating the practical approach to developing a cross-platform library when using any of those as a base, the way things are handled when building for android seem outdated as of the latest releases available for both and more straightforward approaches would help in the development for that platform.

### Libraries Used

#### Rendering Graphics: OpenGL and OpenGLES

OpenGL<sub>[#W16]</sub> is a cross-language API for rendering both 2D and 3D raster graphics, targetting the GPU in order to havehardware-accelerated rendering. Initially released in 1992 by Silicon Graphics Inc., it has been receiving first party support until 2017 with the 4.6 release, being developed by the Khronos Group since 2006.

During the coursing of the Degree in Design and Development of Videogame, OpenGL has been the staple graphics API used for most project alongside WebGL and SDL wrappers. Given that experience it was a quick decision to use such library that is cross-platform capable for the targetted platforms.

OpenGLES<sub>[#W17]</sub> is a cut down version for Embedded Devices such as mobile phones,having almost the same syntax for most operations besides what is or not available and smaller changes in shader language syntax, making it a faster inclusion than targetting other graphics API for Android.

As OpenGLES 3.2, the latest version, mirrors OpenGL Core Version 3.3 more or less the library will stay under that core versions, while circumventing smaller syntax differences.

#### Context Management: EGL and GLFW

In order to display graphics on screen, it is required to have a canvas in which to draw, called Context for some graphics APIs. EGL<sub>[#W15]</sub> is a cross-platfom interface between the Khronos Group rendering APIs and the operating systems windowing systems in order to allow the display of graphics.

The use case in context management for both libraries is to take care of binding of surfaces and buffers to write to, synchronization of the rending with the displays and enibling the accelerating of such operations with the underlying hardware.

GLFW<sub>[#W18]</sub> has more functionalinity in creation of windows and taking care of input, the catch is that is only available in desktop platforms. EGL is a native library to Android, which creates the first platform divide for taking care of different subsystems.

#### User Input: Android NDK and GLFW

The big issue when handling user input between the proposed platforms is that they are completely different. Android input is touch based and in desktop platforms the keyboard and mosue combo are the msot widely used. They are by no means incompatible but by default there are not many options that take care of them in a similar fashion. It was a clear area where a new approach for cross-platform apprach was needed.

The Android NDK<sub>[#W21]</sub> is the provided API by Google in order to interact with Android devices in native C and C++ code. Most interaction to Android requires calling from Java environments, the NDK provides JNI, a Java Native Interface through which access the native systems. Theses native systems includes the main input system.

GLFW takes care of user input in desktop environments in a per window basis, meaning that you can setup direct access to what the user performs and receive that information when needed in each window created.

#### File Access: Native through C++ STL and Android NDK

When developing games, getting hold of files is pretty straightforward, you have load them into memory and then perform any complicated operations with other methods, the same way to write files to the system. 

On Android subsystems the user does not have direct write access, special permissions are required and as such specific functions are required from the NDK in order to access and write files. In desktop environments, using plain C++ is the most straightforward way alongsides some OS specific provided standard libraries.

The meat of this system is to make it truly platform agnostic to the end user.


### Libraries Not Used

It is important to remark that there are many other open source alternatives to most of the libraries that have been used or will be used for the main subsystems of this project. While the great majority are not covered here, most either could be interchangeable or require a lower level understanding of the required subsystem.

The information on the unused libraries should serve as a brief introduction and simple reasons on why they were not used.

| Graphics APIs | Reason |
|---|---|
| Magnum Engine | Unfamiliarity and few entry level documentation |
| Vulkan | Unfamiliarity and oriented to much lower level programming |
| Ogre | UNfamiliarity and provides much more features for animation, scene, effects,etc, which are not required, bloating the project initially with higher entry cost |
| Direct3D/DirectX | Support only for Windows / UWP |

| Context Management | Reason |
|---|---|
| WGL | Windows only support |
| GLEW | Could have been an interchangeable option, but extensions are supported different in Android, incompatible with OpenGLES |

!!! note
    Most context management libraries take only part in generating the OpenGL context, as they should, leaving mroe work into taking care of managing windows through the native systems on Windows and Linux. Although in Windows that would have been more straightforward, due the high variance between distros, that would have been a great time cost.


| Input Libraries | Reason |
|---|---|
| Gainput | Outdated Android toolchain, would have had a lot of costs for building on current versions |

!!! note
    For taking care of accessing files, the only one that I have had previous experience is PhysFS which has fallen in use in recent years although it would be much better and has an Android port but with an outdated toolchain.

## Game Engines

From a user standpoint, public game engines are the most comfortable environments for making games. Development time is cut down drastically with available technologies and accessible, they enhance the creative experience while obfuscating part of the technoilogic requirements for an easier entry.

There are also proprietary engines, which are used and own by specific studios, which benefit from more direct technologic development but they will not be covered here.

Besides the following engines, there are more engines which have differetn features to offer for better or for worse. In this recollection, a brief introduction and basic strengths and weaknesses pertaining to initial development will be taken into account, as well as some developed games.

### Unity

Unity<sub>[#W6]</sub> is a cross-platform game engine, unveiled at Wordwide Developers Conference 2005, built as an OS-X exclusive game engine. Over time it has extended support to other desktop platform and emerging platforms. Nowadays supports most widely available platforms, be it console, mobile, desktop and IOT devices.

| STRENGTHS | WEAKNESSES |
|-------|---------|
| 3D and 2D Game Support | Comparably low performance (including DOTS) |
| Mostly unparalleled platform support | Unsteady direction of development |
| Accessible Interface | Messy Rendering Pipeline support (HDRP, URP, SRP) |
| Open Marketplace for developers of Assets and Tools | Outdated Network System |
| Robust Subsystems for physics, logic and asset management | Slow Build process on mobile platforms |
| Continuous development and improvement of tools and technology| Closed source code |
| Tier based licensing with royalties | |
| Vast knowledge base in tutorials, examples and documentation| |

!!! Tip: Game Examples
    Used in multiple indie games and solo production as well as big studios: Hearthstone (Blizzard-Activision, 2014), Fall Guys (Mediatonic, 2020), Ori and the Will of the Wisps (Moon Studios, 2020), Cuphead(Studio MDHR, 2017), Flappy Bird(Don Nguyen, 2013),...

### Unreal Engine 4

The fourth version coming from the Unreal Engine<sub>[W.7]</sub> series is a great high value production tool for smaller teams and some supported individuals. It started in 1998 as the engine for the first-person shooter game series Unreal Tournament, by Epic Games. The engine has slowly moved into film and TV productions and has been providing support for smaller creators all around.

| STRENGTHS | WEAKNESSES |
|-------|---------|
| Focus on high quality 3D graphics | Lacking support for 2D games |
| Robust an daccessible visual tools for programming and visual effects | Suited for bigger productions |
| Great tools for massive scale projects | Althought better than past, not suitable for low-end device products|
| High performance oriented technology | Outdated UI althought improving at a fast pace |
| Open sourced code | |
| Royalty based licensing starting at one million $ | |
| Open Marketplace for developers of Assets and Tools| |

!!! Tip: Game Examples
    Guilty Gears Strive (Arch Systems, 2021), Fortnite (Epic Games, 2017), A Way Out (Retro Yeti Games, 2018), Ark Survival Evolved (Studio Wildcard, 2017), Batman: Arkham Asylum (Rocksteady Studios, 2016),...

### Godot

The Godot<sub>[#W8]</sub> engine is an open source cross-platform engine, released by Juan Linietsky and Ariel Manzur in 2014, with the latest release being on September 2020. It aims to be as accessible while maintaining the capabilities of a fully fledged comercial engine.

| STRENGTHS | WEAKNESSES |
|---|---|
| Very accessible visual tools for everything it brings | Slower 3D performance for bigger projects |
| High level of customization and expansion | Smaller ecosystem |
| Fully Open Source and free | Smaller industry impact |
| Essential support of major platforms | Slower adoption of newer technologies |
| Flexible language support | Some platforms are only supported through dedicated porting studios |
| Very Strong 2D tool supports | |

!!! Tip: Game Examples
    Human Diaspora (Leocesar3D, 2020), Kingdoms of the Dump (Roach Games, Kickstarter 2019), Ex Zodiac (Ben Hickling, 2021), Resolutiion (Monolith of Minds, 2020),...

### Game Maker Studio 2

Created by Mark Overmars originally in 1999, later acquired by YoYo Games in 2007, the Game Maker<sub>[#W23]</sub> series of engines are cross-platform engines geared to introduce novice programmers to game making. Through a an accessible visual programming language and an extensible scripting language, game maker accomplishes the task of easing the creation of 2D videogames. The latest available release as of htis date, came in November 2020.

| STRENGTHS | WEAKNESSES |
|---|---|
| Accessible and Simple Interface | Lacking 3D support (possible if the user implements it) |
| Drag and Drop creation | Outdated Networkign models |
| Wide availability of documentation and tutorials| Only Free Trial, yearly license per platform |
| Extensive Marketplace | Slower performance |
| Support for major platforms | |
| Strong tools for 2D game creation | |

!!! Tip: Game Examples
    Rivals of Aether (Dan Fornace LLC, 2015), Hyper Light Drifter (Heart Machine, 2016), Katana Zero (Askiisoft, 2019), Risk of Rain (Hopoo Games, 2013), VA-11 Hall-A (Sukeban Games, 2016), The Red Strings Club (Deconstructeam, 2018),...

### GDevelop

GDevelop<sub>[#W10]</sub> is an iniciative started by Florian Rival released in 2008, a game engine based on the web browser technology stack and capable of building for destkop and mobile platforms.

| STRENGTH | WEAKNESSES |
|---|---|
| Greatly Accessible, aimed at non-programmers | No 3D Support |
| Fully open sourced | Slow performance in bigger projects |
| Great documentation and focus on educational content | |
| Builds very easily to supported platforms | |
| Easy support for in-game monetization | |
| Includes game design tools | |
| Provides a complete subsystem package | |

!!! Tip: Game Examples
    Lil BUB's Hello Earth (Mike Bridavsky, 2019), Uphill Climb Racing Neon (Frolics2dio, 2021), Hyperspace Dogfights (Sleeper Games, 2018), Swamp(Afterapocalypse, 2019),...

### Cocos Creator

Cocos Creator<sub>[#W11]</sub> was orignally the development environment for Cocos2d-x, was recently updated to support high performance 3D rendering pipelines (Vulkan and Metal), adding to their web based stack and native backends. Another fully Open Source engine, initially publishde in 2010 by Zhe Wang, is a very accessible engine built upon Cocos2d by Ricardo Quesada, released in 2008.

| STRENGTHS | WEAKNESSES |
|---|---|
| High performance subsystems | Veary young 3D tools |
| Fully open sourced backend | Slow to get updates |
| Lots of community support | |
| Supports multiple scripting languages | |
| Strong multiplatform support | |
| Easy integration of plugins | |
| Complete development package since 3D update | |

!!! Tip: Game Examples
    Imperial Saga (Square Enix, 2015), Rolling Cats (KingWorks, 2018), King Of Fighters Ultimate Match Online (DURPALM, 2018), Idle Heroes (DHGAMES, 2016), Revenge of Sultans (ONEMT, 2016),...

### Defold

Developed by Ragnar Scensson and Christian Murray in 2007 as a lightweight 2D game engine, was acquired by King in 2013. Initially as a licensed engine, in 2016 was released for free for any user and was later ceded to the Defold<sub>[#W12]</sub> Foundation in 2020, making the engine completely open source. Support and investment will be continued by King.

| STRENGTHS | WEAKNESSES |
|---|---|
| Build for fast iteration | Small adoption |
| Support for desktop and major mobile platforms | Lesser availability of tutorials |
| Flexible scripting system | No visual programming tool |
| Strong focuson 2D, with 3D capabilities | |
| Easily Extensible | |
| Integration with popular ad and store platforms | |

!!! Tip: Game Examples
    Travel Blast (MP Games, 2020), Zoom-Be (Flazm, TBA), Interrogation (Critique Gaming, 2019), Fates of Ort (8bitskull, 2020), Family Island (Melsoft, 2019),...

### Lumberyard

In 20015, Amazon licensed CryEngine from Crytek in order to create an engine with native support for the Amazon Web Services (AWS), allowing developers to build and host their games on Amazon's servers. With the acquisition of Twitch, Lumberyard<sub>[#W14]</sub> also has integration with the Twitch Livestreaming API, allowing interaction with the viewers natively. It was publicly launched in 2016 and later made source-available<sub>[#W9]</sub>.

| STRENGTHS | WEAKNESSES |
|---|---|
| Big Company Backing | Owned by Amazon |
| Strong realtime online service and subsystems | Locked in their network solutions and servers |
| Fast update rate | Complicated onboarding process |
| Extensible C++ scripting and visual scripting | Slow IDE performance |
| High perfomance graphic inherited from CryEnine renderer | Unstable releases |
| Lots of examples, tutorials and documentation provided | Slow build times |
| Completely free for offline games | |

!!! Tip: Game Examples
    Star Citizen (Cloud Imperium Games, 2100+), The Grand Tour Game (Amazon Game Studios, 2019), New World (Amazon Game Studios, 2021+), Coffence (Sweet Bandits Studios, 2018),... mostly TBA or cancelled projects.

# Project Planning

The process of developing and refining a framework to build applications is a long task, no frameworks are instantly adopted and have the best entry user experience. There are programming and accessibility challenges that have to be tackled constantly.

It is crucial to maintain a strictly timed environment for tackling the multiple challenges faced.

## Planification Tools

### Gantt Project

The first layer of planification is based on having the main areas of development, defining the required subsystems, examples and documentation steps for acomplishing each task. Instead of primarily defining all the task and steps to be taken, which will vary as time goes on and research on the topics is completed, its best to outline the planned steps.

A Gantt chart feels ideal to decide on timestamps for these tasks and their dependencies, the tool used will be Gantt Project<sub>[#W24]</sub>

![Figure [figures]: Library Development Plan](images/Gantt1.png)
![Figure [figures]: Engine Development Plan](images/Gantt2.png)

### HacknPlan

After checking out multiple tools around task management including Trello, Github Boards, Gitkraken Boards or even custom formats of Google Sheets, the tool I have personally found most useful and flexible has been HacknPlan<sub>[#W25]</sub>.

Great part of the project consists in diving into new content not explored during these formative years, as such a lot of variables will come into place and the initial planning can't be really fully detailed. As such, a flexible task system was required to follow the initial plans and allowing flexible adjustment of tasks.

Trello was the closest in terms of functionality but free accounts have a limit of 10 boards which does not fit well with the free open source approach to this project, and heavy usage pf boards for separating parts is necessary to keep things organized for later transcription.

![Figure [figures]: Example HacknPlan Board used](images/HacknPlan_Board_Example.png)

### Version Control: Github and Gitkraken

Software project are a sum of multiple blocks and constant iteration, during its process it is imperative to have a way to take not of the changes and actions performed. Using a version control system the project becomes easily portable and an easily accessible update log.

Even more important is the fact that the project will be tested and developed in multiple platform, as such the Gitkraken<sub>[#W22]</sub> git GUI client will be used as it has Linux compatibility and some great features for managing repository branchs.

Repositories for the Library and Engine can be found under [#W1] and [#W2].

## Validation

Given that the final result is not only a user oriented product, but a development tool, it is of most importance to keep stability on the designed workflows. As the success metrics of the project fall under ease of use and accessibility for C++ programmers, the following simple approach has been selected to keep the user in mind.
**********************************************************
*.------------------------.   .----------------.
*| Develop Implementation |-->| Create Example |--.
*'------------------------'   '----------------'  |
*           ^                         |           | 
*           |   Usability Iteration   |           |
*           '<------------------------'           |
*           |                                     |
*           |                                     |  
*     .---------------------. Easy+Stable Usablity|
*     | Write Documentation |<--------------------'
*     '---------------------'
*********************************************************
[Figure [figures]: Accessibilty oriented development]

This simple procedure makes the intentions very clear. On first page is getting implementation done and refined alongside a simple example. When developing different examples the true value of the implementation and its superficial flaws are found quickly, making it easier initially to get a more usable product.

As well as the iterative process of development, debug mode checks have been placed in the tool for the user to get notified in any misuses of the library and the errors committed with the implementation. This is explained under the library development section.

## SWOT Analysis

| STRENGTHS | WEAKNESSES |
|---|---|
| Previous experience in engine creation | Long development time with lots of content |
| 5 Years of Experience in C++ and choses experience in used libraries | Lack of experience with cross-platform tools and platforms other than Windows |
| Time and drive to try new things | No experience in state of the art C++ development |

| OPPORTUNITIES | THREATS |
|---|---|
| Entry to multiplatform C++ development is not straight forward, accomplishing a good entry for developers | There are lots of fully feature frameworks and engines one can go to and get faster and better results, as theres more support and documentation available |
| There's no financial risk as a student project | Time is extremely limited, th eproject will fall short on refinement for larger production |

## Risks and Contingencies

Given the scope of the project, the most sensible approach is to identify where the principal chokign points of the project lie and understand where to fall back from those possible stepbacks.

### Development Risks

| Development | Solution |
|---|---|
| Data corruption | Code and Thesis are being worked with version control systems, they can be recovered |
| Development Device failures | Development is done under a Windows and a separate Linux device, both capable, and access to another Windows device that could be setup for development. |
| Android Device Failure | There were initially 2 extra devices available, of which one has had issues. Now there is 1 extra available, all at the required minimum Android Version |

### Planned Task Risks

The development process takes part in OSs that have not been previously explored with C++, as well as a plethora of tools that will be new to use and even find out about. Given the initial uncertainty of the project, a strong buffer of the main expected tasks has to be prepared.

| C++ On Linux | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Development Environment | 5 | 0% |
| Building | 4 | 25% |
| Debugging | 1 | 100% |

| C++ On Android | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Development Environment | 10 | 50% |
| Building | 10 | 100% |
| Debugging | 10 | 100% |

| Library Main Modules | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Display / Window Management | 10 | 10% |
| User Input | 10 | 100% |
| Graphics | 10 | 10% |
| File Access System | 5 | 40% |

| Main Library Examples | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Performance Tests | 2 | 500% |
| Pong | 2 | 50% |
| LearnOpenGL on Library | 6 | 0% |
| ImGui Example | 5 | 20% |

| Base Engine Development | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Enigne UI System | 5 | 40% |
| ECS Structure | 5 | 100% |
| Render Pipeline | 10 | 50% |

| Project Documentation | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Initial Delivery | 10 | 0% |

| Feature Completing Engine | Expected Time (days) | Deviation Buffer | 
|---|---|---|
| Resource Management | 10 | 0% |
| Input System | 5 | 100% |
| Scripting System | 15 | 33% |

| Project Finalization | Expected Time (days) | Deviation Buffer |
|---|---|---|
| Game Jame Time | 15 | 0% |
| Project Polish | 20 | 0% | 

Given the amount of uncertainty in the project, the final steps of the project are aimed at providing a feedback loop on it rather than expand on it. As most tasks involve a high level of uncertainty given unfamiliarity with the systems, this time serves as a buffer for most other tasks. These close to 2 months of finishing development can be reallocated to finishing features and making sure it is as user accessible as possible.

## Cost Analysis

Although the project is aimed at producing open source content, thus not having a financial reach in mind, the development time and resources have to be taken into account and make an approximated calculation of the costs:

### Monetary Costs

![Table [tables]: Approximated costs](images/Cost_Table.png)

# Methodology

Given the initial planning of the project, with previous knowledge of the lack of knowledge in the area, it is expected to have increasing requirements and tasks added to the backlog. Agile methodologies are extremely suited to rapidly changing environments, designating specific sprints for development and allowing for task flexibility in them.

There are multiple methodologies that have been developed from the Agile principles, as the project is developed by a single person it makes little sense on focusing on most methods which have been designed to coordinate group efforts. Having said that, a variable sprint approach to the Agile methodology fit this project the most.

## Variable Sprint Agile

***************************************************************************
*        .----------------------------------------------------------.
*        |                      Positive Reception                  |
*        v                                                          |
*.--------------.   .------------.   .---------.   .------.   .----------.
*| Next  Sprint |-->| Plan Tasks |-->| Develop |-->| Test |-->| Feedback |
*'--------------'   '------------'   '---------'   '------'   '----------'
*                          ^             ^            |             |
*                          |             | Not Stable |             |
*                          |             '------------'             |
*                          |                                        |
*                          |           Negative Reception           |
*                          '----------------------------------------'
***************************************************************************
[Figure [figures]: Simplification of the Agile Process]

In Agile methodology, it is expected to have clear cut sprints through which things are performed and then they are passed down to next sprints when failure to achieve occurrs. Given the variability of the project and even the building blocks of it, an approach to a simplified Agile process without a specific task backlog is required.

### Sprints

Sprints take between two weeks and a month in the project, but the task inside are orientative rather than strict tasks, as such each sprint requires initial planning and research for task creation. After that the Agile process takes place and used to continue development.

### Progress Tracking

In the planning phase of a sprint, the elements cut-off or non achieved from the previous sprint which do not affect the next steps are reflected upon and backlogged or added as active tasks. After categorizing non-finished tasks, a retrospective on what has made that happen is performed and noted for improvement in next sprints.

## Tracking Tools

As mentioned previously in planification, the main tool for tracking the sprints and measuring progress is HacknPlan. The project manager offers a great approach to task and subtask generation as well as an easy to quantify log system, making it great for taking a look back at each sprint.

# SqueLib Development

# SqueMaker Development

# SqueLib Sample Projects

# SqueMaker Sample Projects

# Conclusions

# Webgraphy
<!-- 
[#WX]: Title: Description. Author, Year.
<url> 
-->
[#W1]: SqueLib: A C++ multiplatform library and framework. Marc Torres Jimenez, 2021.
<https://github.com/MarcFly/SqueLib>

[#W2]: SqueMaker: A C++ game engine based on SqueLib. Marc Torres Jimenez, 2021.
<https://github.com/MarcFly/SqueMaker>

[#W3]: KDE. KDE e.V., 1998.
<https://kde.org/>

[#W4]: The 3-Clause BSD License. Regents of the University of California, 1999. 
<https://opensource.org/licenses/BSD-3-Clause>

[#W5]: Open Source Software. Open Source Initiative, 1998.
<https://opensource.org/>

[#W6]: Unity. Unity Technologies, 2005.
<https://unity.com/> 

[#W7]: Unreal Engine. Epic Games, 2014.
<https://www.unrealengine.com/en-US/> 

[#W8]: Godot. Juan Linietsky and Ariel Manzur, 2014.
<https://godotengine.org/showcase> 

[#W9]: Source available, Open Source, Free Software. Phil Haack, 2006.
<https://haacked.com/archive/2006/07/26/CodeAvailableVsOpenSourceVsFreeSoftware.aspx/>

[#W10]: GDevelop. Florian Rival, 2008.
<https://gdevelop-app.com/>

[#W11]: Cocos Creator. Chukong Technologies, 2019.
<https://www.cocos.com/creator> 

[#W12]: Defold. Ragnar Scensson and Christian Murray, 2007.
<https://defold.com/> 

[#W13]: Lumberyard. Amazon, 2016.
<https://aws.amazon.com/es/lumberyard/> 

[#W14]: Awesome Cpp. fffaraz, 2015.
<https://github.com/fffaraz/awesome-cpp>

[#W15]: EGL. Khronos Group, 2014.
<https://www.khronos.org/egl>

[#W16]: OpenGL. Silicon Graphics Inc, 1992.
<https://www.opengl.org/>

[#W17]: OpenGLES. Khronos Group, 2002.
<https://www.khronos.org/opengles/>

[#W18]: GLFW. GLFW Development Team, 2002.
<https://www.glfw.org/>

[#W19]: Simple DirectMedia Layer. SDL Community, 1998.
<https://www.libsdl.org/>

[#W20]: RayLib. Ramon Santamaria, 2013.
<https://www.raylib.com/>

[#W21]: Android NDK. Google, 2009.
<https://developer.android.com/ndk>

[#W22]: Gitkraken. Axosoft, 2015.
<https://www.gitkraken.com/>

[#W23]: Game Maker Studio 2. YoYo Games, 2016.
<https://www.yoyogames.com/get>

[#W24]: Gantt Project. Alexandre Thomas, 2003.
<https://www.ganttproject.biz/>

[#W25]: HacknPlan. Christian Estévez López, 2015.
<https://hacknplan.com/>

<!--
<script src="markdeep-thesis/lib/bindery/2.2.9/bindery.min.js"></script>
<script>
    markdeepThesisOptions = {
        view: "print",
        titlePage: titlePage,
        fontSize: 12,
        extraBinderyRules: [

        ],
        runningHeader: function (page) {
            if(page.heading.h1 == undefined)
                return ``
            else
                return `${page.heading.h1}~ ${page.number}`
        },
        markdeepDiagramScale: 0.8
    }
</script>
<script src="markdeep-thesis/markdeep-thesis.js"></script>
-->
<script src="markdeep-thesis/lib/markdeep/1.11/markdeep.min.js" charset="utf-8"></script>
